---
title: "Fst_01172022"
author: "Sophia Buysse"
date: "1/17/2022"
output: html_document
---
Need document with less strict filtering parameters... why not just use the allsites one? try that first to see if it works honestly.
script is called Fst_sub_SNPs_2022.R

module purge
module load  GCC/9.3.0  OpenMPI/4.0.3 R/4.0.3

```{r pairwise_fst_HPCC, eval = FALSE}
library(dplyr)
library(tidyr)
library("pegas")
library("diveRsity")

##### pegas #####

# number of row
#e <- 101063418 # this is the allsites file
e1 <- 3230225 # less strict filtering
#e2 <- 1398791 # more strict filtering (same as GWAS file)


# read in data
# use the biallelic.variant file b/c it is only the variant sites with the less strict filtering. This is not the same file that is used for the GWAS.
dat1 <- read.vcf("/mnt/research/josephslab/Sophie/Athal_2/GVCF/biallelic.variant.vcf.gz",
                 from = 1, to = e1)

# the file that is used for the GWAS is found at /mnt/research/josephslab/Sophie/Athal_2/GVCF/allSNPs.noIndelsMafp05MaxMissp75BiallelicQ30Dp5.vcf.gz

##### diveRsity #####

# transpose (switch columns and rows)
dat2 <- t(dat1)
str(dat2)
colnames(dat2) <- toupper(colnames(dat2))
colnames(dat2)
# make column names all uppercase so can classify population by first three characters
class(dat2)

rownames(dat2) <- 1:e1
# remove .. from rownames and just have them be numbers
head(dat2)
class(dat2)
# still matrix array

# add column of the rownames to function as SNP_ID because the location didn't come through with the vcf
# used cbind!
dat2 <- as.data.frame(cbind(rownames(dat2),dat2))
colnames(dat2)[1] <- "SNP_ID"
head(dat2)
class(dat2)
#data.frame

# same for rownames
dat2 <- rbind(colnames(dat2), dat2)
head(dat2)

# lapply! make characters into readable format
dat2 <- lapply(dat2, chartr, old = "|", new = "/")
dat2 <- lapply(dat2, gsub, pattern = "/", replacement = "")

# need to do both of these because some are / and some |
# can't use this gsub for the period because it interprets the . as an anything characte$
dat2 <- lapply(dat2, chartr, old = ".", new = "-")
# there was definitely an easier way to do this. oh well!
dat2 <- as.data.frame(dat2)
head(dat2)

save(dat2, file = 'GenotypeMatrix_filtered.biallelic.ROBJ')

#### subset 100,000 randomly chosen SNPs for fst matrix ####
rows_keep <- runif(n = 100000, min = 2, max = e1)
rows_keep <- c(1,rows_keep)
# need to keep row one for the ID, set rows_keep to start at two so I never have row 1 twice
# want to keep all columns because each column is an individual, only filter rows
dat_sub <- dat2[rows_keep, ]
str(dat_sub)
class(dat_sub)
length(dat_sub$SNP_ID)

# writes to working directory
setwd("~/Documents")
snp2gen(infile = dat_sub, prefix_length = 3)

#clear list to clear up space

rm(list = ls())

### let's try to get some stats out
test_output <- fastDivPart(infile = "~/Documents/snp2gen_converted.gen", outfile = "fastDivPart_sub_SNPs", gp = 2, pairwise = TRUE, fst = TRUE)
# write test_output to a file... or maybe save as an R object?
# maybe not necessary because the matrix will be in the output file, but let's save as a
save(test_output, file = "fastDivPart_sub_SNPS_2022")

```

fst_sub_2022.sh sbatch script to run the script called Fst_sub_SNPs_2022.R
batch job 44024238

# Visualizing Fst pairwise matrix: diveRsity

```{r fst_heatmap, eval = TRUE}

##### visualizing fst matrices
library(RColorBrewer)
library(pheatmap)
## functions

## to fill in top part of matrix
makeSym <- function(m) {
  m[upper.tri(m)] <- t(m)[upper.tri(m)]
  return(m)
}

##### for 10,000 randomly chosen snps #####
## read in the matrix
#sub_10k <- read.delim("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/PopGen/fastDivPart_10000/Fst_mat.txt",
 #                     quote = "")
sub_10k <- read.delim("~/Documents/fastDivPart_sub_SNPS_2022", quote = "")
## reorganize
sub_10k$X.16 <- NULL
rownames(sub_10k) <- sub_10k[1,]
colnames(sub_10k) <- sub_10k[,1]
sub_10k <- sub_10k[2:17,2:17]
sub_10k <- lapply(sub_10k, as.numeric)
test <- as.matrix(as.data.frame(sub_10k))
rownames(test) <- colnames(test)
str(test)

# get a mean and sd
test2 <- as.vector(test)
sum_fst <- c(mean(test2, na.rm = TRUE), sd(test2, na.rm = TRUE))

test <- makeSym(test)
str(test)

diag(test) <- 0

str(test)
fst_mat <- test
rownames(fst_mat) <- substr(rownames(fst_mat), start = 1, stop = 3)
colnames(fst_mat) <- substr(colnames(fst_mat), start = 1, stop = 3)
substr(rownames(fst_mat),1,3)[substr(rownames(fst_mat),1,3) == 'ARB'] <- "ARU"
substr(colnames(fst_mat),1,3)[substr(colnames(fst_mat),1,3) == 'ARB'] <- "ARU"
substr(rownames(fst_mat),1,3)[substr(rownames(fst_mat),1,3) == 'SPE'] <- "SAL"
substr(colnames(fst_mat),1,3)[substr(colnames(fst_mat),1,3) == 'SPE'] <- "SAL"
save(fst_mat, file = "C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/Fst_matrix.ROBJ")

pdf("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/Fst_heatmap.pdf", height = 9, width = 11)
heatmap(x = fst_mat, symm = TRUE,
        xlab = "Population",
        ylab = "Population",
        main = "Fst Heatmap", 
        #keep.dendro = FALSE,
        #Rowv = NA,
        col= colorRampPalette(brewer.pal(8, "Oranges"))(255))
legend(x="bottomright", legend=c("0", "0.5", "1"),
     fill=colorRampPalette(brewer.pal(8, "Oranges"))(3))
dev.off()

## now mess around with the order of everything to see what happens.
rownames(fst_mat)
# currently in alphabetical order.
# manually double check that the order is correct.
meta <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/pop_metadata.csv")
# add a vector in the order of elevation, did this manually because I'm lazy today and reordering factors is always confusing.
elev <- c(1229, 416, 441, 1444, 715, 519, 413, 836, 1585, 1706, 177, 665, 61, 303, 991, 1605)
elev.simp <- c(12, 5, 6, 13, 9, 7, 4, 10, 14, 16, 2, 8, 1, 3, 11 ,15)
elev.nam <- c('RAB', 'PIN', 'SAL', 'HOR', 'ARU', 'BAR', 'COC', 'POB', 'BOS', 'MUR', 'VDM', 'ALE', 'BIS', 'PAL', 'VIE', 'PAN')
# doesn't want a character, does want the elevation value.
## so far this adventure is a failure.

#pdf("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/Fst_heatmap.elev.pdf", height = 9, width = 11)
heatmap(x = fst_mat, symm = TRUE,
        xlab = "Population",
        ylab = "Population",
        main = "Fst Heatmap", 
        keep.dendro = FALSE,
        Rowv = elev.simp,
        col= colorRampPalette(brewer.pal(8, "Oranges"))(255))
legend(x="bottomright", legend=c("0", "0.5", "1"),
     fill=colorRampPalette(brewer.pal(8, "Oranges"))(3))
#dev.off()

## maybe it would be easier to reorder the matrix? scary time.
## to do that, would want to go back to before I make it symmetric I think (sub_10k object)
elev_mat <- as.data.frame(sub_10k)
colnames(elev_mat) <- substr(colnames(elev_mat), start = 1, stop = 3)
colnames(elev_mat)[colnames(elev_mat) == 'ARB'] <- "ARU"
colnames(elev_mat)[colnames(elev_mat) == 'SPE'] <- "SAL"
rownames(elev_mat) <- colnames (elev_mat)
elev_mat <- makeSym(elev_mat)
elev_mat <- as.matrix(elev_mat[elev.nam , elev.nam])
row.labs <- paste0(elev.nam, " - ", elev[order(elev)], "m")


pheatmap(elev_mat, cluster_rows = FALSE, cluster_cols = FALSE, color = colorRampPalette(brewer.pal(n = 9, name =
  "YlOrRd"))(100), border_color = NA, labels_row = row.labs, fontsize_row = 15, fontsize_col = 15, filename = "C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/fst_heatmap_elevation.png",height = 9, width = 9)


```


Using genind for hierfstat

The modules needed to load changed on 1/24/2022

```{bash}
module purge
module load iccifort/2020.1.217  impi/2019.7.217 R/4.0.3
R

```

```{r}
library(vctrs)
library(pegas)
library('adegenet')
e1 <- 3230225 # less strict filtering
dat1 <- read.vcf("/mnt/research/josephslab/Sophie/Athal_2/GVCF/biallelic.variant.vcf.gz",
                 from = 1, to = e1)
class(dat1)
#loci, dataframe

# make a subset so this doesn't take FOREVER

#### subset 100,000 randomly chosen SNPs for fst matrix ####
cols_keep <- runif(n = 100000, min = 2, max = e1)
# want to keep all rows because each is an individual, only filter the columns
dat_sub <- dat1[,cols_keep ]
str(dat_sub)
class(dat_sub)
# add a population column
dat_sub$population <- toupper(substr(rownames(dat_sub), 1, 3))
class(dat_sub)
dat_sub2 <- as.loci(dat_sub, col.pop = 'population', checkSNP = FALSE)
class(dat_sub2)

dat2 <- loci2genind(dat_sub2, ploidy = 2)
save(dat2, file = '~/R/Documents/SNPs_sub_2022_genind.ROBJ')
```

Successfully made this file on 1/19/2022! Now to actually do the calculations with it.

```{r}
library(dplyr)
library(adegenet)
library(hierfstat)
library(poppr)

load('~/Documents/SNPs_sub_2022_genind.ROBJ')
dat2
popNames(dat2)

# these are stats that should be calculated with the whole dataset rather than the subset
locmiss = propTyped(dat2, by = "loc")
#locmiss[which(locmiss < 0.80)] # print iff more than 20% missing
# could also plot this as a bar plot
hist(locmiss)
# everything is above 0.75 so most do not have more than 20% missing which is good

# there are actually like a lot of NAs which might be a problem.

indmiss = propTyped(dat2, by = "ind")
#indmiss[which(indmiss < 0.80)]
hist(indmiss)
# everything is above 0.65. most above 0.90. looks like only 2 or 4 are below 0.80
dat_filtered = missingno(dat2, type = "geno", cutoff = 0.20)
# Removing 2 genotypes: ALE16_GCTACGCT-TAGATCGC, BAR11_CAGAGAGG-TATCCTCT
# these genotypes had more than 20% missing. I don't really like this because it is just a subset so that feels wrong...

### check for unique genotypes
##mlg(dat_filtered)
### identify duplicates and remove (should already be done)
##dups = mlg.id(dat_filtered)
##for (i in dat_filtered){ # for each element in the list object
##if (length(dat_filtered[i]) > 1){ # if the length is greater than 1
##print(i) # print individuals that are duplicates
##  }
##}
### see webpage if  Ineed to remove any duplicates.

isPoly(dat2) %>% summary
##   Mode   FALSE    TRUE
##  logical    6295   93705


## Basic info
#table(dat2$loc.fac) # num alleles per locus
summary(dat2$pop) #sample size for each pop
# 3 or 4 for all, as expected
##private_alleles(dat2) %>% apply(MARGIN = 1, FUN = sum) # private alleles per site across all loci

## now miving into hierfstat, so change the data format
dat3 <- genind2hierfstat(dat2)
dat3
allelic.richness(dat3$Ar %>% apply(MARGIN = 2, FUN = mean) %>%
  round(digits = 3) # mean allelic richness per site
# this did not work 

# Hierfstat basic stats
basic_stats = basic.stats(dat2, diploid = TRUE)

# Mean observed heterozygosity per site
Ho_lobster = apply(basic_lobster$Ho, MARGIN = 2, FUN = mean, na.rm = TRUE) %>%
round(digits = 2)
Ho_lobster
# Mean expected heterozygosity per site
He_lobster = apply(basic_lobster$Hs, MARGIN = 2, FUN = mean, na.rm = TRUE) %>%
round(digits = 2)
He_lobster
# Create a data.frame of site names, Ho and He and then convert to long format
Het_lobster_df = data.frame(Site = names(Ho_lobster), Ho = Ho_lobster, He = He_lobster) %>%
melt(id.vars = "Site")

#inbreeding coefficient
apply(basic_lobster$Fis, MARGIN = 2, FUN = mean, na.rm = TRUE) %>%
round(digits = 3)

# Fst
# Subset data sets to reduce computation time
lobster_gen_sub = popsub(lobster_gen, sublist = c("Ale","Ber","Brd","Pad","Sar17","Vig"))
seafan_gen_sub = popsub(seafan_gen, sublist = c("Bla","Bov","Bre","Lun","PorI","Sko"))
# Compute pairwise Fsts
all_fst = genet.dist(dat2, method = "WC84")
all_fst %>% round(digits = 3)
# one visualization option
# Convert dist object to data.frame
fst.matrix = as.matrix(lobster_fst)
ind = which( upper.tri(fst.matrix), arr.ind = TRUE)
fst.df = data.frame(Site1 = dimnames(fst.matrix)[[2]][ind[,2]],
Site2 = dimnames(fst.matrix)[[1]][ind[,1]],
Fst = fst.matrix[ ind ] %>% round(digits = 3))
# Convert minus values to zero
fst.df$Fst[fst.df$Fst < 0] = 0
# Print data.frame summary
fst.df %>% str
## 'data.frame': 15 obs. of 3 variables:
## $ Site1: chr "Ber" "Brd" "Brd" "Pad" ...
## $ Site2: chr "Ale" "Ale" "Ber" "Ale" ...
## $ Fst : num 0.12 0.131 0.007 0.14 0.025 0.008 0.066 0.174 0.171 0.161 ...
# Fst italic label
fst.label = expression(italic("F")[ST])
# Extract middle Fst value for gradient argument
mid = max(fst.df$Fst) / 2
# Plot heatmap
ggplot(data = fst.df, aes(x = Site1, y = Site2, fill = Fst))+
16
geom_tile(colour = "black")+
geom_text(aes(label = Fst), color="black", size = 3)+
scale_fill_gradient2(low = "blue", mid = "pink", high = "red", midpoint = mid, name = fst.label, limits = c(0, max(fst.df$Fst)), breaks = c(0, 0.05, 0.10, 0.15))+
scale_x_discrete(expand = c(0,0))+
scale_y_discrete(expand = c(0,0), position = "right")+
theme(axis.text = element_text(colour = "black", size = 10, face = "bold"),
axis.title = element_blank(),
panel.grid = element_blank(),
panel.background = element_blank(),
legend.position = "right",
legend.title = element_text(size = 14, face = "bold"),
leg
```