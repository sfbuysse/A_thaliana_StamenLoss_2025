plot(Comp$Full_PopFlwrMean ~ Comp$Seq_PopFlwrMean)
lines(x = c(0,1,2), y = c(0,1,2))
plot(Comp$Seq_PopFlwrMean ~ Comp$Seq_LSM)
lines(x = c(0,1,2), y = c(0,1,2))
cor.test(Comp$Full_PopFlwrMean, Comp$Full_Block)
View(Sequenced)
## load data
Full <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_ByFlwr.csv")
Sequenced <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
PopMetaData <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv", header=TRUE)
Full$Population <- as.factor(substr(x=Full$Population, 1, 3))
Full$Matriline <- as.factor(Full$Matriline)
Full$Plant <- as.factor(toupper(Full$Plant))
Full$PlantingBlock <- as.factor(Full$PlantingBlock)
Full$Tube <- as.factor(Full$Tube)
Full$Notes <- NULL
str(Full)
Sequenced <- Sequenced[,1:9]
Sequenced$Population <- as.factor(Sequenced$Population)
View(Sequenced)
Sequenced <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
View(Sequenced)
Sequenced$Population <- as.factor(Sequenced$Population)
Sequenced$Line <- as.factor(Sequenced$Line)
Sequenced$PlantingBlock <- as.factor(Sequenced$PlantingBlock)
Sequenced$Rep <- as.factor(toupper(Sequenced$Rep))
# Plant is equivalent to Rep
Sequenced$Tube <- as.factor(Sequenced$Tube)
str(Sequenced)
## create a fully nested random model
colnames(Full)
# the important ones are Pop, Line, Rep, Tube to mimic what Jeff used
# Population
# Matriline
# Plant
# Tube = timepoint so there are multiple flowers for each tube
# this doesn't include the flower b/c we want a mean
# doesn't use PlantingBlock Either.
# full random model
F_m1 <- lmer(NumShortStamens ~ (1|Population) + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# mixed model
F_m2 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# full fixed model
F_m3 <- lm(NumShortStamens ~ Population + Matriline + Plant + Tube,
data = Full)
# add in planting block
F_m4 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population) + (1|PlantingBlock),
data = Full)
summary(F_m1)
summary(F_m2)
summary(F_m4)
anova(F_m1)
anova(F_m2)
anova(F_m4)
## create a fully nested random model
colnames(Sequenced)
# full random model
S_m1 <- lmer(Short_Stamens ~ (1|Population) + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# full fixed model
S_m3 <- lm(Short_Stamens ~ Population + Line + Rep + Tube, data = Sequenced)
# add in planting block
S_m4 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population) + (1|PlantingBlock),
data = Sequenced)
summary(S_m2)
summary(S_m4)
anova(S_m2)
anova(S_m4)
Full_LSM <- summary(emmeans(F_m2, spec = "Population"))
# include block
Full2_LSM <- summary(emmeans(F_m4, spec = "Population"))
# quick check correlation
cor(Full_LSM$emmean, Full2_LSM$emmean)
# 0.9845071
# yayayayayaya!!
Seq_LSM <- summary(emmeans(S_m2, spec = "Population"))
# include block
Seq2_LSM <- summary(emmeans(S_m4, spec = "Population"))
# quick check correlation
cor(Seq_LSM$emmean, Seq2_LSM$emmean)
Full_RawMeans <- Full %>% group_by(Population) %>%
summarize(Full_PopFlwrMean = mean(NumShortStamens))
Seq_RawMeans <- Sequenced %>% group_by(Population) %>%
summarize(Seq_PopFlwrMean = mean(Short_Stamens))
# Create an output file (.ROBJ is good enough I think) with the Population, SSN, and elevation as metadata
Elev_Means <- merge(Full_RawMeans, Seq_RawMeans, by = "Population")
Elev_Means$Elev_m <- PopMetaData$Elev_m[match(Elev_Means$Population, PopMetaData$PopCode)]
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean, "Seq_Block" - Seq2_LSM$emmean)
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean, "Seq_Block" = Seq2_LSM$emmean)
Comp <- merge(Elev_Means, LSMs, by = "Population")
View(Comp)
cor.test(Comp$Seq_PopFlwrMean, Comp$Seq_Block)
plot(Comp$Seq_PopFlwrMean ~ Comp$Seq_Block)
lines(x = c(0,1,2), y = c(0,1,2))
library(dplyr)
library(ggplot2)
eigenValues_test <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_plinkFilterTest.eigenval", sep = " ", header = F)
eigenVectors_test <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_plinkFilterTest.eigenvec", sep = " ", header = F)
# each row is a genotype, each column is a PC.
colnames(eigenVectors_test) <- c("Line", "SeqID", paste0("PC", 1:(ncol(eigenVectors_test)-2)))
library(dplyr)
library(ggplot2)
eigenValues_test <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_plinkFilterTest.eigenval", sep = " ", header = F)
eigenVectors_test <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_plinkFilterTest.eigenvec", sep = " ", header = F)
# each row is a genotype, each column is a PC.
colnames(eigenVectors_test) <- c("Line", "SeqID", paste0("PC", 1:(ncol(eigenVectors_test)-2)))
eigenValues_noBOS <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_noBOS.eigenval", sep = " ", header = F)
eigenVectors_noBOS <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_noBOS.eigenvec", sep = " ", header = F)
# each row is a genotype, each column is a PC.
colnames(eigenVectors_noBOS) <- c("Line", "SeqID", paste0("PC", 1:(ncol(eigenVectors_noBOS)-2)))
eigenValues_noCent <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_noCent.eigenval", sep = " ", header = F)
eigenVectors_noCent <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_noCent.eigenvec", sep = " ", header = F)
# each row is a genotype, each column is a PC.
colnames(eigenVectors_noCent) <- c("Line", "SeqID", paste0("PC", 1:(ncol(eigenVectors_noCent)-2)))
eigenValues_noCent_noBOS <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_nocent_noBOS.eigenval", sep = " ", header = F)
eigenVectors_noCent_noBOS <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_nocent_noBOS.eigenvec", sep = " ", header = F)
# each row is a genotype, each column is a PC.
colnames(eigenVectors_noCent_noBOS) <- c("Line", "SeqID", paste0("PC", 1:(ncol(eigenVectors_noCent_noBOS)-2)))
pve_test <- round((eigenValues_test / (sum(eigenValues_test))*100), 2)
pve_test$PC <- c(1:20)
pve_pruned <- round((eigenValues_pruned / (sum(eigenValues_pruned))*100), 2)
pve_noBOS <- round((eigenValues_noBOS / (sum(eigenValues_noBOS))*100), 2)
pve_noBOS$PC <- c(1:20)
# definite drop after first four, 1 is 13, 2 is 10, 3 is 8.3, 4 is 7.` and the rest scale from 6 down to 2.25
pve_noCent <- round((eigenValues_noCent / (sum(eigenValues_noCent))*100), 2)
pve_noCent$PC <- c(1:20)
# matches the NO BOS results almost exactly? strange...
pve_noCent_noBOS <- round((eigenValues_noCent_noBOS / (sum(eigenValues_noCent_noBOS))*100), 2)
pve_noCent_noBOS$PC <- c(1:20)
# add pop column
eigenVectors_test$Pop <- toupper(substr(eigenVectors_test$Line, 1, 3))
eigenVectors_noBOS$Pop <- toupper(substr(eigenVectors_noBOS$Line, 1, 3))
eigenVectors_noCent$Pop <- toupper(substr(eigenVectors_noCent$Line, 1, 3))
eigenVectors_noCent_noBOS$Pop <- toupper(substr(eigenVectors_noCent_noBOS$Line, 1, 3))
# change ARB -> ARU and SPE -> SAL
eigenVectors_test[eigenVectors_test$Pop == "ARB", "Pop"] <- "ARU"
eigenVectors_test[eigenVectors_test$Pop == "SPE", "Pop"] <- "SAL"
eigenVectors_noBOS[eigenVectors_noBOS$Pop == "ARB", "Pop"] <- "ARU"
eigenVectors_noBOS[eigenVectors_noBOS$Pop == "SPE", "Pop"] <- "SAL"
eigenVectors_noCent[eigenVectors_noCent$Pop == "ARB", "Pop"] <- "ARU"
eigenVectors_noCent[eigenVectors_noCent$Pop == "SPE", "Pop"] <- "SAL"
eigenVectors_noCent_noBOS[eigenVectors_noCent_noBOS$Pop == "ARB", "Pop"] <- "ARU"
eigenVectors_noCent_noBOS[eigenVectors_noCent_noBOS$Pop == "SPE", "Pop"] <- "SAL"
# load the meta data
metadata <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv", header = TRUE)
# clean up a little
metadata <- metadata[1:16,c("Population", "PopCode", "Elev_m", "Lat_DecDeg", "Lon_DecDeg")]
# merge
eigenVectors_test$elev <- metadata$Elev_m[match(eigenVectors_test$Pop, metadata$PopCode)]
# then match with row names to add metadata column
# do this for lat and long now too
eigenVectors_test$lat <- metadata$Lat_DecDeg[match(eigenVectors_test$Pop, metadata$PopCode)]
eigenVectors_test$lon <- metadata$Lon_DecDeg[match(eigenVectors_test$Pop, metadata$PopCode)]
eigenVectors_noBOS$elev <- metadata$Elev_m[match(eigenVectors_noBOS$Pop, metadata$PopCode)]
# then match with row names to add metadata column
# do this for lat and long now too
eigenVectors_noBOS$lat <- metadata$Lat_DecDeg[match(eigenVectors_noBOS$Pop, metadata$PopCode)]
eigenVectors_noBOS$lon <- metadata$Lon_DecDeg[match(eigenVectors_noBOS$Pop, metadata$PopCode)]
eigenVectors_noCent$elev <- metadata$Elev_m[match(eigenVectors_noCent$Pop, metadata$PopCode)]
# then match with row names to add metadata column
# do this for lat and long now too
eigenVectors_noCent$lat <- metadata$Lat_DecDeg[match(eigenVectors_noCent$Pop, metadata$PopCode)]
eigenVectors_noCent$lon <- metadata$Lon_DecDeg[match(eigenVectors_noCent$Pop, metadata$PopCode)]
eigenVectors_noCent_noBOS$elev <- metadata$Elev_m[match(eigenVectors_noCent_noBOS$Pop, metadata$PopCode)]
# then match with row names to add metadata column
# do this for lat and long now too
eigenVectors_noCent_noBOS$lat <- metadata$Lat_DecDeg[match(eigenVectors_noCent_noBOS$Pop, metadata$PopCode)]
eigenVectors_noCent_noBOS$lon <- metadata$Lon_DecDeg[match(eigenVectors_noCent_noBOS$Pop, metadata$PopCode)]
# order by elevation and make labels column
eigenVectors_test <- eigenVectors_test[order(eigenVectors_test$elev),]
eigenVectors_test$label <- paste0(eigenVectors_test$Pop, " - ", eigenVectors_test$elev, "m")
#eigenVectors_test$Pop <- as.factor(eigenVectors_test$Pop)
eigenVectors_test$Pop <- factor(eigenVectors_test$Pop, levels = unique(eigenVectors_test$Pop[order(eigenVectors_test$elev)]))
str(eigenVectors_test)
eigenVectors_noBOS <- eigenVectors_noBOS[order(eigenVectors_noBOS$elev),]
eigenVectors_noBOS$label <- paste0(eigenVectors_noBOS$Pop, " - ", eigenVectors_noBOS$elev, "m")
eigenVectors_noBOS$Pop <- factor(eigenVectors_noBOS$Pop, levels = unique(eigenVectors_noBOS$Pop[order(eigenVectors_noBOS$elev)]))
eigenVectors_noCent <- eigenVectors_noCent[order(eigenVectors_noCent$elev),]
eigenVectors_noCent$label <- paste0(eigenVectors_noCent$Pop, " - ", eigenVectors_noCent$elev, "m")
eigenVectors_noCent$Pop <- factor(eigenVectors_noCent$Pop, levels = unique(eigenVectors_noCent$Pop[order(eigenVectors_noCent$elev)]))
eigenVectors_noCent_noBOS <- eigenVectors_noCent_noBOS[order(eigenVectors_noCent_noBOS$elev),]
eigenVectors_noCent_noBOS$label <- paste0(eigenVectors_noCent_noBOS$Pop, " - ", eigenVectors_noCent_noBOS$elev, "m")
eigenVectors_noCent_noBOS$Pop <- factor(eigenVectors_noCent_noBOS$Pop, levels = unique(eigenVectors_noCent_noBOS$Pop[order(eigenVectors_noCent_noBOS$elev)]))
# let's make a subset dataframe of the variables we are interested in
cor_test <- eigenVectors_test[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon")]
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
round(cor(cor_test), 2)
cot.test
cor.test
cor_test
head(eigenVectors_test)
# let's make a subset dataframe of the variables we are interested in
cor_test <- eigenVectors_test[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
# let's make a subset dataframe of the variables we are interested in
cor_test <- eigenVectors_test[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
cor_noBOS <- eigenVectors_noBOS[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
cor_noCent <- eigenVectors_noCent[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
cor_noCent_noBOS <- eigenVectors_noCent_noBOS[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
summary_test <- cor_test %>%
group_by(Pop) %>%
summarize("elev" = mean(elev), "lat" = mean(lat), "lon" = mean(lon), "PC1" = mean(PC1), "PC2" = mean(PC2), "PC3" = mean(PC3), "PC4" = mean(PC4))
View(summary_test)
round(cor(summary_test), 2)
round(cor(summary_test[ ,2:7]), 2)
round(cor(summary_test[ ,2:8]), 2)
cor.test(summary_test$elev, summary_test$PC1)
# p = 0.0009217, cor = -0.745
cor.test(summary_test$elev, summary_test$PC2)
round(cor(summary_test[ ,2:8]), 2)
# p = 0.03083, cor = -0.5400
cor.test(summary_test$elev, summary_test$PC3)
cor.test(summary_test$elev, summary_test$PC4)
cor.test(summary_test$elev, summary_test$PC3)
cor.test(summary_test$elev, summary_test$PC4)
?scale_color_manual()
?ggplot2::scale_color_manual
?save()
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
load("data/decay_chr.ROBJ")
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
ggplot(decay_chr) +
geom_line(aes(x = grp, y = r2_mean, col = as.factor(CHR_A), group = as.factor(CHR_A)))+
geom_point(aes(x = grp, y = r2_mean, col = as.factor(CHR_A)))+
scale_color_manual(name = "Chromosome", values = cbPalette)+
labs(x = "Distance Between SNPs (kb)", y = "Average R2")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90, hjust=0.25))
ggplot(decay_chr) +
geom_line(aes(x = grp, y = r2_mean, col = as.factor(CHR_A), group = as.factor(CHR_A)))+
geom_point(aes(x = grp, y = r2_mean, col = as.factor(CHR_A)))+
scale_color_manual(name = "Chromosome", values = cbPalette)+
labs(x = "Distance Between SNPs (kb)", y = "Average R2")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))
ggplot(decay_chr) +
geom_line(aes(x = grp, y = r2_mean, col = as.factor(CHR_A), group = as.factor(CHR_A)))+
geom_point(aes(x = grp, y = r2_mean, col = as.factor(CHR_A)))+
scale_color_manual(name = "Chromosome", values = cbPalette)+
labs(x = "Distance Between SNPs (kb)", y = "Average R2")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(decay_chr) +
geom_line(aes(x = grp, y = r2_mean, col = as.factor(CHR_A), group = as.factor(CHR_A)))+
geom_point(aes(x = grp, y = r2_mean, col = as.factor(CHR_A)))+
scale_color_manual(name = "Chromosome", values = cbPalette)+
labs(x = "Distance Between SNPs (kb)", y = "Average R2")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(decay_chr) +
geom_line(aes(x = grp, y = r2_mean, col = as.factor(CHR_A), group = as.factor(CHR_A)))+
geom_point(aes(x = grp, y = r2_mean, col = as.factor(CHR_A)))+
scale_color_manual(name = "Chromosome", values = cbPalette)+
labs(x = "Distance Between SNPs (kb)", y = "Average R2")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(decay_chr) +
geom_line(aes(x = grp, y = r2_mean, col = as.factor(CHR_A), group = as.factor(CHR_A)))+
geom_point(aes(x = grp, y = r2_mean, col = as.factor(CHR_A)))+
scale_color_manual(name = "Chromosome", values = cbPalette)+
labs(x = "Distance Between SNPs (kb)", y = "Average R2")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggsave(filename = "LD_decay_chr.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/supp", height = 7, width = 7, device = "png", dpi = 500)
knitr::opts_chunk$set(echo = TRUE)
# read in packages
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(qqman))
# list of all the files I am interested in
files <- c("NoCent.PlinkFiltering_Binary.c", "NoCent.PlinkFiltering_raw.c",  "NoCent.PlinkFiltering_Asin.c", "NoCent.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Asin.c", "allSNPs.PlinkFiltering_raw.c", "allSNPs.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Binary.c", "allSNPs.PlinkFiltering_raw_subset.c", "NoCent.PlinkFiltering_raw_subset.c")
# could then theoretically lapply my function to this list of names
# does not include the testing file b/c not needed here.
library(praise)
##### do it time 3 #####
# read in top hits file
#top_hits_fdr_all <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/Top_hits_fdr_wald_Apr2023.csv")
top_hits_fdr_all <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/Top_hits_fdr_wald_Apr2023.csv")
##### do it time 3 #####
# read in top hits file
#top_hits_fdr_all <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/Top_hits_fdr_wald_Apr2023.csv")
top_hits_fdr_all <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/Top_hits_fdr_wald_Apr2023.csv")
#make a 1000bp window centered on the SNP
top_hits_fdr_all$min <- top_hits_fdr_all$ps - 500
top_hits_fdr_all$max <- top_hits_fdr_all$ps + 500
# adding elevation back in on 1/25/2024 because I need the overlap analysis to be consistent between everything.
# using the "inverse of all' code so the first three columns are kept
th_nocent <- top_hits_fdr_all[, grep("all", colnames(top_hits_fdr_all), value = TRUE, invert = TRUE)]
View(th_nocent)
# using the 'inverse of nocent' code so the first three columns are also kept
th_all <- top_hits_fdr_all[, grep("nc", colnames(top_hits_fdr_all), value = TRUE, invert = TRUE)]
View(th_nocent)
# so count NAs, and  keep rows with fewer than 15 NAs (5 columns should have values for all rows)
# expect this to reduce rows that were only in all or only in nocent now that I've split them up.
th_nocent <- th_nocent[rowSums(is.na(th_nocent)) < 15 , ]
# sample size went down by ~3000
th_all <- th_all[rowSums(is.na(th_all)) < 15 , ]
# nested loops that give me an output that is a list of dataframes with at least 2 overlapping SNPs in the window
# after commenting out and testing on chromosome 5, it did keep the 1 SNP I had identified that should have been included and wasn't previously (5:13458838) which I think is a good sign, and the second function really cut down the included windows enough so I am going to commit, then remove the commented out lines from  the id_snps function that filter for only having 2+ rows because I don't need them anymore
id_snps <- function(input){
output <- list()
len <- length(input$ps) # to this point works
# loop that makes a list of all SNPs in the window
for (i in c(1:len)){
tmp_list <- c(input$min[i]:input$max[i])
tmp_df <- data.frame()
# loop that checks if snps in the dataframe are in the list of all SNPs in the window
for (j in c(1:len)){
if (input$ps[j] %in% tmp_list) {
tmp_df <- rbind(tmp_df, input[j, ])}
}
# add new dataframe to a list of dataframes to be in the output
output <- append(output, list(tmp_df))
}
return(output)
}
# include elev
nc_p_cols <- c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc", "p_elev_nc")
all_p_cols <- c("p_binary_all", "p_raw_all", "p_asin_all", "p_subset_all", "p_elev_all")
gwas_overlap <- function(input, keep_cols){
cols_with_values <- c()
for(d in c(1:length(input))){
cols_with_values[d] <- sum(colSums(is.na(input[[d]][,keep_cols])) < length(input[[d]][ ,1]))
}
# then write out the dataframes from the initial list
output <- input[c(cols_with_values > 1)]
return(output)
}
##testing further below, but it seems to work!
praise()
##### no cent #####
# only keep the p value columns
hits_fdr_chr1 <- th_nocent[(th_nocent$chr == 1), c("chr", "rs", "ps", grep("p_", colnames(th_nocent), value = TRUE), "min", "max")]
# run that function!
chr1_overlap_nc <- id_snps(hits_fdr_chr1)
#1823 elements
length(unique(chr1_overlap_nc)) # 103 unique, 210 when including windows with only 1 SNP
# check for overlap between gwas types
OverlapHits_chr1_nc <- gwas_overlap(chr1_overlap_nc, nc_p_cols)
View(OverlapHits_chr1_nc)
OverlapHits_chr1_nc[[1]]
##### all  #####
# only keep the p value columns
hits_fdr_chr1_a <- th_all[(th_all$chr == 1), c("chr", "rs", "ps", grep("p_", colnames(th_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr1_overlap_all <- id_snps(hits_fdr_chr1_a) # 306 elements
length(unique(chr1_overlap_all)) # 118 are unique, 244 are unique when including windows with only 1 SNP
# fancy function 2
OverlapHits_chr1_all <- gwas_overlap(chr1_overlap_all, all_p_cols)
hits_fdr_chr2 <- th_nocent[(th_nocent$chr == 2), c("chr", "rs", "ps", grep("p_", colnames(th_nocent), value = TRUE), "min", "max")]
# run that function!
chr2_overlap_nc <- id_snps(hits_fdr_chr2)
#1823 elements
length(unique(chr2_overlap_nc)) # 1184 unique
# check for overlap between gwas types
OverlapHits_chr2_nc <- gwas_overlap(chr2_overlap_nc, nc_p_cols)
hits_fdr_chr2_a <- th_all[(th_all$chr == 2), c("chr", "rs", "ps", grep("p_", colnames(th_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr2_overlap_all <- id_snps(hits_fdr_chr2_a) # 1676 elements
length(unique(chr2_overlap_all)) # 1093 are unique
# fancy function 2
OverlapHits_chr2_all <- gwas_overlap(chr2_overlap_all, all_p_cols)
hits_fdr_chr3 <- th_nocent[(th_nocent$chr == 3), c("chr", "rs", "ps", grep("p_", colnames(th_nocent), value = TRUE), "min", "max")]
# run that function!
chr3_overlap_nc <- id_snps(hits_fdr_chr3)
#4301 elements
length(unique(chr3_overlap_nc)) # 2580 unique
# check for overlap between gwas types
OverlapHits_chr3_nc <- gwas_overlap(chr3_overlap_nc, nc_p_cols)
# list of 58
hits_fdr_chr3_a <- th_all[(th_all$chr == 3), c("chr", "rs", "ps", grep("p_", colnames(th_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr3_overlap_all <- id_snps(hits_fdr_chr3_a) # 3124 elements
length(unique(chr3_overlap_all)) # 1933 are unique
# fancy function 2
OverlapHits_chr3_all <- gwas_overlap(chr3_overlap_all, all_p_cols)
# list of 44
##### no cent #####
# only keep the p value columns
hits_fdr_chr4 <- th_noelev_nocent[(th_noelev_nocent$chr == 4), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
##### no cent #####
# only keep the p value columns
hits_fdr_chr4 <- th_nocent[(th_nocent$chr == 4), c("chr", "rs", "ps", grep("p_", colnames(th_nocent), value = TRUE), "min", "max")]
# run that function!
chr4_overlap_nc <- id_snps(hits_fdr_chr4)
#1202 elements
length(unique(chr4_overlap_nc)) # 1647 unique
# check for overlap between gwas types
OverlapHits_chr4_nc <- gwas_overlap(chr4_overlap_nc, nc_p_cols)
hits_fdr_chr4_a <- th_all[(th_all$chr == 4), c("chr", "rs", "ps", grep("p_", colnames(th_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr4_overlap_all <- id_snps(hits_fdr_chr4_a) # 3124 elements
length(unique(chr4_overlap_all)) # 1933 are unique
# fancy function 2
OverlapHits_chr4_all <- gwas_overlap(chr4_overlap_all, all_p_cols)
# list of 44
# only keep the p value columns
hits_fdr_chr5 <- th_nocent[(th_nocent$chr == 5), c("chr", "rs", "ps", grep("p_", colnames(th_nocent), value = TRUE), "min", "max")]
# run that function!
chr5_overlap_nc <- id_snps(hits_fdr_chr5)
#1202 elements
length(unique(chr5_overlap_nc)) # 761 unique
# check for overlap between gwas types
OverlapHits_chr5_nc <- gwas_overlap(chr5_overlap_nc, nc_p_cols)
hits_fdr_chr5_a <- th_all[(th_all$chr == 5), c("chr", "rs", "ps", grep("p_", colnames(th_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr5_overlap_all <- id_snps(hits_fdr_chr5_a) # 1344 elements
length(unique(chr5_overlap_all)) # 938 are unique
# fancy function 2
OverlapHits_chr5_all <- gwas_overlap(chr5_overlap_all, all_p_cols)
#3437 elements
length(unique(chr5_overlap_nc)) # 761 unique
14+16+44+58+94+101+10+6+77+61
View(OverlapHits_chr1_all)
OverlapHits_chr1_all[[1]]
bind_rows(OverlapHits_chr1_all, .id = "column_label")
all_1 <- bind_rows(OverlapHits_chr1_all, .id = "column_label")
all_2 <- bind_rows(OverlapHits_chr2_all, .id = "column_label")
all_3 <- bind_rows(OverlapHits_chr3_all, .id = "column_label")
all_4 <- bind_rows(OverlapHits_chr4_all, .id = "column_label")
all_5 <- bind_rows(OverlapHits_chr5_all, .id = "column_label")
overlap_all <- rbind(all_1, all_2, all_3, all_4, all_5)
View(overlap_all)
unique(overlap_all$rs)
length(unique(overlap_all$rs))
View(overlap_all)
View(overlap_all)
?distinct()
all_1 <- bind_rows(OverlapHits_chr1_all)
all_2 <- bind_rows(OverlapHits_chr2_all)
all_3 <- bind_rows(OverlapHits_chr3_all)
all_4 <- bind_rows(OverlapHits_chr4_all)
all_5 <- bind_rows(OverlapHits_chr5_all)
overlap_all <- rbind(all_1, all_2, all_3, all_4, all_5)
length(unique(overlap_all$rs))
# hmm okay so this dataframe has 2386 observations but only 282 of them are actually unique rows and the rest are duplicates that are snps that show up in multiple windows....
overlap_all2 <- distinct(overlap_all)
View(overlap_all2)
nc_1 <- bind_rows(OverlapHits_chr1_nc)
nc_2 <- bind_rows(OverlapHits_chr2_nc)
nc_3 <- bind_rows(OverlapHits_chr3_nc)
nc_4 <- bind_rows(OverlapHits_chr4_nc)
nc_5 <- bind_rows(OverlapHits_chr5_nc)
overlap_nc <- rbind(nc_1, nc_2, nc_3, nc_4, nc_5)
length(unique(overlap_nc$rs))
# hmm okay so this dataframe has 2806 observations but only 289 of them are actually unique rows and the rest are duplicates that are snps that show up in multiple windows....
overlap_nc2 <- distinct(overlap_nc)
?write.csv
getwd()
write.csv(overlap_all2, file = "data/AllChrs_Overlap_20240125.csv", row.names = FALSE)
write.csv(overlap_nc2, file = "data/NoCent_Overlap_20240125.csv", row.names = FALSE)
all_1 <- bind_rows(OverlapHits_chr1_all, .id = "window")
View(all_1)
# one window does not have elevation, is only other
all_2 <- bind_rows(OverlapHits_chr2_all, .id = "window")
View(all_2)
# all windows include an elevation hit
all_3 <- bind_rows(OverlapHits_chr3_all, .id = "window")
all_4 <- bind_rows(OverlapHits_chr4_all, .id = "window")
all_5 <- bind_rows(OverlapHits_chr5_all, .id = "window")
View(all_4)
View(all_5)
View(all_1)
View(all_2)
View(all_4)
View(all_3)
View(overlap_all2)
library(dplyr)
library(ggplot2)
# read in data from local machine this time!
# plink filter, all
eigenValues_test <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_plinkFilterTest.eigenval", sep = " ", header = F)
eigenVectors_test <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_plinkFilterTest.eigenvec", sep = " ", header = F)
# each row is a genotype, each column is a PC.
colnames(eigenVectors_test) <- c("Line", "SeqID", paste0("PC", 1:(ncol(eigenVectors_test)-2)))
# calculate the PVE. Remember that I used 20 PCs, so this PVE is out of 20 PCs
pve_test <- round((eigenValues_test / (sum(eigenValues_test))*100), 2)
pve_test$PC <- c(1:20)
eigenVectors_test$Pop <- toupper(substr(eigenVectors_test$Line, 1, 3))
eigenVectors_test[eigenVectors_test$Pop == "ARB", "Pop"] <- "ARU"
eigenVectors_test[eigenVectors_test$Pop == "SPE", "Pop"] <- "SAL"
# load the meta data
metadata <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv", header = TRUE)
# clean up a little
metadata <- metadata[1:16,c("Population", "PopCode", "Elev_m", "Lat_DecDeg", "Lon_DecDeg")]
# merge
eigenVectors_test$elev <- metadata$Elev_m[match(eigenVectors_test$Pop, metadata$PopCode)]
# then match with row names to add metadata column
# do this for lat and long now too
eigenVectors_test$lat <- metadata$Lat_DecDeg[match(eigenVectors_test$Pop, metadata$PopCode)]
eigenVectors_test$lon <- metadata$Lon_DecDeg[match(eigenVectors_test$Pop, metadata$PopCode)]
eigenVectors_test <- eigenVectors_test[order(eigenVectors_test$elev),]
eigenVectors_test$label <- paste0(eigenVectors_test$Pop, " - ", eigenVectors_test$elev, "m")
#eigenVectors_test$Pop <- as.factor(eigenVectors_test$Pop)
eigenVectors_test$Pop <- factor(eigenVectors_test$Pop, levels = unique(eigenVectors_test$Pop[order(eigenVectors_test$elev)]))
str(eigenVectors_test)
# let's make a subset dataframe of the variables we are interested in
cor_test <- eigenVectors_test[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
summary_test <- cor_test %>%
group_by(Pop) %>%
summarize("elev" = mean(elev), "lat" = mean(lat), "lon" = mean(lon), "PC1" = mean(PC1), "PC2" = mean(PC2), "PC3" = mean(PC3), "PC4" = mean(PC4))
round(cor(summary_test[ ,2:8]), 2)
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
cor.test(summary_test$elev, summary_test$lat)
# cor = 0.58, p = 0.017
cor.test(summary_test$elev, summary_test$lon)
