#add this info to the initial data set (so like adding new column and sorting by it)
left_join(forplot, ., by=c("CHR"="CHR")) %>%
#add cum position of each SNP
arrange(CHR, BP) %>%
mutate( psCum=BP+tot)
axisdf = don %>% group_by(CHR) %>% summarize(center=( max(psCum) + min(psCum) ) /2 )
#sig.level is set in the function line. is 0.05 default but not expecting hits above that.
bonferroni_sig <- sig.level/length(forplot$P)
# and plot. should just make the 1 plot.
# split don into shared SNPs and not shared SNPs, then merging together so the shared snps are at the bottom of the dataframe and will be plotted on top of the other points.
# hopefully dn't need to also make QTL ones plotted near bottom...
don_a <- don[don$shared == "#00FF00FF", ]
don_b <- don[don$shared != "#00FF00FF", ]
don_c <- rbind(don_b, don_a)
# start plot with don_b because that is most of what I'll need
m_plot <- ggplot(don_c, aes(x=psCum, y=-log10(P))) +
geom_point(aes(fill = fdr_col, color = shared), shape = 21, size = 1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "#FFC107", linetype = "dashed", alpha = 0.6)+
geom_segment(aes(x = 21551000, y = -0.001, xend = 30245000, yend = -0.001), col = "red")+
scale_fill_manual(values = alpha(levels(don_c$fdr_col),0.8)) +
scale_color_manual(values = levels(don_c$shared))+
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= bquote(-log[10](p)))+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
ggsave(paste0(fig_name,".png"), plot = m_plot, width = 7, height = 3, dpi = 700, units = "in")
don[don$CHR == 3 & don$BP == 7329000, ]
View(don_a)
View(don)
3417327 - 53539822
53539822-3417327
# start plot with don_b because that is most of what I'll need
m_plot <- ggplot(don_c, aes(x=psCum, y=-log10(P))) +
geom_point(aes(fill = fdr_col, color = shared), shape = 21, size = 1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "#FFC107", linetype = "dashed", alpha = 0.6)+
geom_segment(aes(x = 21551000, y = -0.1, xend = 30245000, yend = -0.1), col = "red")+
geom_segment(aes(x = (50122495+7329000), y = -0.1, xend = (50122495+ 8201000), yend = -0.1), col = "red")+
geom_segment(aes(x = 21551000, y = -0.001, xend = 30245000, yend = -0.001), col = "red")+
scale_fill_manual(values = alpha(levels(don_c$fdr_col),0.8)) +
scale_color_manual(values = levels(don_c$shared))+
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= bquote(-log[10](p)))+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
ggsave(paste0(fig_name,".png"), plot = m_plot, width = 7, height = 3, dpi = 700, units = "in")
# start plot with don_b because that is most of what I'll need
m_plot <- ggplot(don_c, aes(x=psCum, y=-log10(P))) +
geom_point(aes(fill = fdr_col, color = shared), shape = 21, size = 1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "#FFC107", linetype = "dashed", alpha = 0.6)+
geom_segment(aes(x = 21551000, y = -0.1, xend = 30245000, yend = -0.1), col = "red")+
geom_segment(aes(x = (50122495+7329000), y = -0.1, xend = (50122495+ 8201000), yend = -0.1), col = "red")+
geom_segment(aes(x =(92167091+2408000 ), y = -0.001, xend = (92167091+2986000 ), yend = -0.001), col = "red")+
scale_fill_manual(values = alpha(levels(don_c$fdr_col),0.8)) +
scale_color_manual(values = levels(don_c$shared))+
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= bquote(-log[10](p)))+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
ggsave(paste0(fig_name,".png"), plot = m_plot, width = 7, height = 3, dpi = 700, units = "in")
# start plot with don_b because that is most of what I'll need
m_plot <- ggplot(don_c, aes(x=psCum, y=-log10(P))) +
geom_point(aes(fill = fdr_col, color = shared), shape = 21, size = 1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "#FFC107", linetype = "dashed", alpha = 0.6)+
geom_segment(aes(x = 21551000, y = -0.3, xend = 30245000, yend = -0.3), col = "black")+
geom_segment(aes(x = (50122495+7329000), y = -0.3, xend = (50122495+ 8201000), yend = -0.3), col = "black")+
geom_segment(aes(x =(92167091+2408000 ), y = -0.3, xend = (92167091+2986000 ), yend = -0.3), col = "black")+
scale_fill_manual(values = alpha(levels(don_c$fdr_col),0.8)) +
scale_color_manual(values = levels(don_c$shared))+
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= bquote(-log[10](p)))+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
ggsave(paste0(fig_name,".png"), plot = m_plot, width = 7, height = 3, dpi = 700, units = "in")
# start plot with don_b because that is most of what I'll need
m_plot <- ggplot(don_c, aes(x=psCum, y=-log10(P))) +
geom_point(aes(fill = fdr_col, color = shared), shape = 21, size = 1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "#FFC107", linetype = "dashed", alpha = 0.6)+
geom_segment(aes(x = 21551000, y = -0.3, xend = 30245000, yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x = (50122495+7329000), y = -0.3, xend = (50122495+ 8201000), yend = -0.3), col = "black")+
geom_segment(aes(x =(92167091+2408000 ), y = -0.3, xend = (92167091+2986000 ), yend = -0.3), col = "black")+
scale_fill_manual(values = alpha(levels(don_c$fdr_col),0.8)) +
scale_color_manual(values = levels(don_c$shared))+
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= bquote(-log[10](p)))+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
ggsave(paste0(fig_name,".png"), plot = m_plot, width = 7, height = 3, dpi = 700, units = "in")
# start plot with don_b because that is most of what I'll need
m_plot <- ggplot(don_c, aes(x=psCum, y=-log10(P))) +
geom_point(aes(fill = fdr_col, color = shared), shape = 21, size = 1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "#FFC107", linetype = "dashed", alpha = 0.6)+
geom_segment(aes(x = 21551000, y = -0.3, xend = 30245000, yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x = (50122495+7329000), y = -0.3, xend = (50122495+ 8201000), yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x =(92167091+2408000 ), y = -0.3, xend = (92167091+2986000 ), yend = -0.3), col = "black", lineend = "round")+
scale_fill_manual(values = alpha(levels(don_c$fdr_col),0.8)) +
scale_color_manual(values = levels(don_c$shared))+
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= bquote(-log[10](p)))+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
ggsave(paste0(fig_name,".png"), plot = m_plot, width = 7, height = 3, dpi = 700, units = "in")
##### Code #####
## load libraries:
library(sf)
library(raster)
library(tmap)
library(grid)
# load World data from the tmap package
data("World")
# cut down to just the Spain data
spain <- World[World$iso_a3 == "ESP", ]
# load the population metadata for population locations
metadata <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/pop_metadata.csv")
# load the population metadata for population locations
metadata <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv")
# load the elevation raster, downloaded from WorldClim. Highest resolution is best because on small scale.
elev_raster = raster("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/WorldClim/Elev/wc2.1_30s_elev.tif")
# crop elevation raster down to the size of spain
spain_elev <- crop(elev_raster, spain)
plot(spain_elev)
# Make a spatial polygon that includes only the pyrenees region
# got extent values from the min and max lat and long of the populations (originally -0.50, 3.5, 41.00, 43.00)
# but max x is actually 3.16, so changes to 3.2
# but this means the pyrenees extend out beyond the limits of spain... becuase the spain elev raster x max is 3.04
pyrenees <- as(extent(-0.50, 3.2, 41.00, 43.00), 'SpatialPolygons')
# set the coordinate reference system to match the elevation and World dataset
crs(pyrenees) <- "+proj=longlat +datum=WGS84 +no_defs"
# Get the location for points and set coordinate reference system
pop_loc <- data.frame(lon = metadata$Lon_DecDeg, lat = metadata$Lat_DecDeg, pop = metadata$PopCode) %>%
st_as_sf(coords = c("lon", "lat"), crs = '+proj=longlat +datum=WGS84 +no_defs ')
View(metadata)
metadata <- metadata[1:16, ]
# Get the location for points and set coordinate reference system
pop_loc <- data.frame(lon = metadata$Lon_DecDeg, lat = metadata$Lat_DecDeg, pop = metadata$PopCode) %>%
st_as_sf(coords = c("lon", "lat"), crs = '+proj=longlat +datum=WGS84 +no_defs ')
pop_coc <- data.frame(lon = c(metadata$Lon_DecDeg, 3.19), lat = c(metadata$Lat_DecDeg,42.31), pop = c(metadata$PopCode, "COC_Cast")) %>%
st_as_sf(coords = c("lon", "lat"), crs = '+proj=longlat +datum=WGS84 +no_defs ')
st_is_longlat(pop_loc)
# First, make a quick map without detail.
# this would be a good subset panel to show which region is shown in detail.
outline <- tm_shape(spain) +
tm_borders("black", lwd = 1)+
tm_shape(pyrenees) +
tm_borders("red", lwd = 1)
outline
tmap_save(outline, "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/OutlineMap.png", dpi = 1000)
# Then, make the detailed map
# Now crop elevation raster down to pyrenees region, with a little buffer for labels to fit
pyr_elev <- crop(elev_raster, as(extent(-0.50, 3.5, 41.00, 43.00), 'SpatialPolygons'))
# manual jitter for labels -> built in jitter (auto.placement) was too random and not lining up well.
pop_loc2 <- data.frame(lon = c(metadata$Lon_DecDeg[1:6], metadata$Lon_DecDeg[7]-0.04,
metadata$Lon_DecDeg[8:10], metadata$Lon_DecDeg[11]+0.04,
metadata$Lon_DecDeg[12:16]),
lat = c(metadata$Lat_DecDeg[1:5]+0.06, metadata$Lat_DecDeg[6]+0.05, metadata$Lat_DecDeg[7]-0.06,
metadata$Lat_DecDeg[8]+0.06, metadata$Lat_DecDeg[9]-0.06,
metadata$Lat_DecDeg[10:16]+0.06),
pop = metadata$PopCode) %>%
st_as_sf(coords = c("lon", "lat"), crs = '+proj=longlat +datum=WGS84 +no_defs ')
st_is_longlat(pop_loc2)
tmap_mode("plot")
# add columns for color and shape control
# manually checked with scheme from other figures. could have done this with more automation with rep() and ordering by elevation?
pop_loc$for.cols <- as.factor(c("red", "red", "red", "green", "yellow", "red", "green",
"blue", "yellow", "yellow", "blue", "green", "green", "blue", "blue", "yellow"))
pop_loc$for.shape <- as.factor(c(2,0,1,0,0,5,1,0,2,1,5,2,5,2,1,5))
# as.factor is important.
pop_loc$pop <- as.factor(pop_loc$pop)
tm_shape(pyr_elev)+
tm_raster(palette = terrain.colors(10), alpha = 0.6, title = "Elevation")+
tm_legend(legend.position = c("right", "bottom"))+
tm_shape(pop_loc2)+
tm_text('pop', col = 'black', auto.placement = FALSE)+
tm_shape(pop_loc)+
tm_symbols('for.cols', palette=c(blue = 'blue', green = 'green', red = 'red', yellow = 'orange'),
stretch.palette = FALSE, size = 0.5, shape = 'for.shape',
shapes = c('0' = 22, '1' = 21, '2' = 24, '5' = 23),
legend.col.show = FALSE, legend.shape.show =  FALSE)
tm_shape(pyr_elev)+
tm_raster(palette = terrain.colors(10), alpha = 0.6, title = "Elevation")+
tm_scale_bar(position = c("right", "bottom"))+
tm_legend(legend.position = c("right", "bottom"))+
tm_shape(pop_loc2)+
tm_text('pop', col = 'black', auto.placement = FALSE)+
tm_shape(pop_loc)+
tm_symbols('for.cols', palette=c(blue = 'blue', green = 'green', red = 'red', yellow = 'orange'),
stretch.palette = FALSE, size = 0.5, shape = 'for.shape',
shapes = c('0' = 22, '1' = 21, '2' = 24, '5' = 23),
legend.col.show = FALSE, legend.shape.show =  FALSE)
## trying to find elevation of this population. based on this, it should be the 500 number and not the 200 number.
tmp_coc <- crop(elev_raster, as(extent(3.0, 3.5, 42.2, 42.4), 'SpatialPolygons'))
tm_shape(tmp_coc)+
tm_raster(palette = terrain.colors(10), alpha = 0.6, title = "Elevation")+
tm_legend(legend.position = c("right", "bottom"))+
tm_shape(pop_loc2)+
tm_text('pop', col = 'black', auto.placement = FALSE)+
tm_shape(pop_coc)+
tm_symbols()
tm_shape(tmp_coc)+
tm_raster(palette = terrain.colors(10), alpha = 0.6, title = "Elevation")+
tm_scale_bar(position = c("right", "bottom"))+
tm_legend(legend.position = c("right", "bottom"))+
tm_shape(pop_loc2)+
tm_text('pop', col = 'black', auto.placement = FALSE)+
tm_shape(pop_coc)+
tm_symbols()
#8/3/2023 update - working on different coloring scheme
# add columns for color and shape control
# manually checked with scheme from other figures. could have done this with more automation with rep() and ordering by elevation?
pop_loc$for.cols <- as.factor(c("red", "red", "red", "green", "yellow", "red", "green",
"blue", "yellow", "yellow", "blue", "green", "green", "blue", "blue", "yellow"))
pop_loc$elev <- as.factor(c(1229, 416, 441, 1444, 715, 519, 413, 836, 1585, 1706, 177, 665, 61, 332, 991, 1605))
pop_loc$for.shape <- as.factor(c(2,0,1,0,0,5,1,0,2,1,5,2,5,2,1,5))
# as.factor is important.
pop_loc$pop <- as.factor(pop_loc$pop)
# try to color like background
tm_shape(pyr_elev)+
tm_raster(palette = terrain.colors(16), alpha = 0.6, title = "Elevation")+
tm_scale_bar(position = c("right", "bottom"))+
tm_legend(legend.position = c("right", "bottom"))+
tm_shape(pop_loc2)+
tm_text('pop', col = 'black', auto.placement = FALSE)+
tm_shape(pop_loc)+
tm_symbols('elev', palette=terrain.colors(16),
stretch.palette = TRUE, size = 0.5, shape = 'for.shape',
shapes = c('0' = 22, '1' = 21, '2' = 24, '5' = 23),
legend.col.show = TRUE, legend.shape.show =  FALSE)
# just make a black point
black <-  tm_shape(pyr_elev)+
tm_raster(palette = terrain.colors(16), alpha = 0.8, title = "Elevation")+
tm_scale_bar(position = c("right", "bottom"))+
tm_legend(scale = 0.4, legend.outside = FALSE, legend.position = c("right", "bottom"))+
tm_shape(pop_loc2)+
tm_text('pop', col = 'black', auto.placement = FALSE, size = 1)+
tm_shape(pop_loc)+
tm_symbols(col = "black", border.col = "black", shape = 21,
stretch.palette = TRUE, size = 0.25,
legend.col.show = FALSE, legend.shape.show =  FALSE)
black
tmap_save(black, "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/BlackDotMap.png",
dpi = 1000,
outer.margins = c(0, 0, 0, 0),
insets_tm = outline,
insets_vp = viewport(x = unit(0.15, "npc"),
y = unit(0.18, "npc"),
width = unit(0.35, "npc"),
height = unit(0.35, "npc"),
default.units = "npc",
just = "centre",gp = gpar(),
clip = "inherit",
mask = "inherit",
xscale = c(0, 1),
yscale = c(0, 1),
angle = 0,
layout = NULL,
layout.pos.row = NULL, layout.pos.col = NULL,name = NULL),
width = 3 ,
height = 2,
units = 'in',
add.titles = "test")
load("04_Elev_Means_Feb2022.ROBJ")
one <- Elev_Means
load("Elev_Means_Feb2022")
load("Elev_Means_Feb2022.ROBJ")
rm(Elev_Means)
load("Elev_Means_Feb2022.ROBJ")
identical(Elev_means, one)
identical(Elev_Means, one)
knitr::opts_chunk$set(echo = TRUE)
## load data
Sequenced <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
PopMetaData <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv")
## load packages
library(emmeans)
library(lme4)
library(dplyr)
library(rcompanion) ## for plotNormalHistogram and blom functions (really don't need anymore if use hist() function)
library(rcompanion) ## for plotNormalHistogram and blom functions (really don't need anymore if use hist() function)
library(MASS) ## for boxcox transformation
library(bestNormalize)
## format columns as factors
Sequenced <- Sequenced[,1:9]
Sequenced$SeqSampleID <- as.factor(Sequenced$SeqSampleID)
Sequenced$Population <- as.factor(Sequenced$Population)
Sequenced$Line <- as.factor(Sequenced$Line)
Sequenced$Rep <- as.factor(toupper(Sequenced$Rep))
# Plant is equivalent to Rep
Sequenced$Tube <- as.factor(Sequenced$Tube)
str(Sequenced)
## calculate raw means
Seq_RawMeans <- Sequenced %>% group_by(SeqSampleID) %>%
summarize(Seq_LineFlwrMean = mean(Short_Stamens))
# only keep some of the metadata that will be important later on
PopMetaData <- PopMetaData[, c("PopCode", "Elev_m")]
# LSMs
## create a fully nested random model
colnames(Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ SeqSampleID + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
S_m3 <- lmer(Short_Stamens ~ Line:Population + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
anova(S_m2)
Seq_LSM <- summary(emmeans(S_m2, spec = "SeqSampleID"))
# compare values
Comp <- merge(Seq_RawMeans, Seq_LSM, by = "SeqSampleID")
View(Comp)
# let's see a correlations
cor.test(Comp$Seq_LineFlwrMean, Comp$emmean)
# to do transformations, I really only care about the distribution of the means, not which line they belong to
raw_means <- Seq_RawMeans$Seq_LineFlwrMean
plotNormalHistogram(raw_means)
shapiro.test(raw_means)
# best normalize package
# tests Yeo-Johnson, Box Cox, log10(x+a), sqrt(x+a), and arcsinh
# a = max(0, -min(x)+eps)
# can use new_transform argument to give best Normalise a list of functions to also use (I think this is basically what I am doing by hand below??)
bestNormalize(raw_means, standardize = FALSE, warm = TRUE)
# squared
means_squared <- raw_means^2
# square root
means_sqrt <- sqrt(raw_means)
# cubic root
means_cubrt <- (raw_means)^(1/3)
# log10
means_log10 <- log10(raw_means)
# natural log
means_log <- log(raw_means)
#inverse
means_inv <- (raw_means)^(-1)
# exponential
means_exp <- exp(raw_means)
# asin_proportion
# doesn't work on values greater than 1 b/c is for proportions
means_asin <- asin(raw_means/2)
# asin_prop_sqrt
# some sources (https://www.programmingr.com/tutorial/arcsine-transformation/) describe the arcsine transformation as needing to be arcsine of the square root
means_asin_sqrt <- asin(sqrt(raw_means/2))
# tukey
means_tukey <- transformTukey(raw_means)
box <- MASS::boxcox(raw_means ~ 1, lambda = seq(-5,5,0.1))
cox <- data.frame(box$x, box$y)
cox2 <- cox[with(cox, order(-cox$box.y)),]
cox2[1,]
lambda <- cox2[1, "box.x"]
means_bc_bn <- predict(bc)
# boxcox
bc <- bestNormalize::boxcox(raw_means)
means_bc_bn <- predict(bc)
means_bc_MASS <- ((raw_means^lambda)-1)/lambda
# rank (don't want to use this one b/c it basically forces a normal distribution)
# could be an comparison though? maybe not.
means_qqnorm <- qqnorm(raw_means, plot = F)
means_rank <- means_qqnorm[["x"]]
# blom - is a rank based method
means_blom <- blom(raw_means, method = "blom", alpha = 3/8, complete = T, na.last = NA)
###### make a list of my new phenotype lists #####
transformations <- list("raw" = raw_means, "squared" = means_squared, "sqrt" = means_sqrt, "Cube rt" = means_cubrt, "Log 10" = means_log10, "Natural Log" = means_log, "inverse" = means_inv, "exponential" = means_exp, "Asin of Proportion" = means_asin, "Asin of Sqrt(proportion)" = means_asin_sqrt, "Tukey" = means_tukey, "BoxCox (BestNormalize)" = means_bc_bn, "BoxCox (MASS)" = means_bc_MASS, "Rank" = means_rank, "Blom" = means_blom)
## make plots of everything
for (i in 1:length(transformations)){
plotNormalHistogram(transformations[[i]], main = names(transformations)[i])
}
## and do shapiro wilks tests
SW_test <- lapply(transformations, shapiro.test)
View(SW_test)
SW_test[["Asin of Sqrt(proportion)"]]
knitr::opts_chunk$set(echo = TRUE, tidy.opts = list(width.cutoff=75), tidy = TRUE)
## load packages
require(emmeans)
require(lme4)
require(dplyr)
#require(lsmeans)
## load data
Full <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_ByFlwr.csv")
Sequenced <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
PopMetaData <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv", header=TRUE)
## format columns as factors for both datasets
Full$Population <- as.factor(substr(x=Full$Population, 1, 3))
Full$Matriline <- as.factor(Full$Matriline)
Full$Plant <- as.factor(toupper(Full$Plant))
Full$PlantingBlock <- as.factor(Full$PlantingBlock)
Full$Tube <- as.factor(Full$Tube)
Full$Notes <- NULL
str(Full)
Sequenced <- Sequenced[,1:9]
Sequenced$Population <- as.factor(Sequenced$Population)
Sequenced$Line <- as.factor(Sequenced$Line)
Sequenced$Rep <- as.factor(toupper(Sequenced$Rep))
# Plant is equivalent to Rep
Sequenced$Tube <- as.factor(Sequenced$Tube)
str(Sequenced)
## create a fully nested random model
colnames(Full)
# full random model
F_m1 <- lmer(NumShortStamens ~ (1|Population) + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# mixed model
F_m2 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# full fixed model
F_m3 <- lm(NumShortStamens ~ Population + Matriline + Plant + Tube,
data = Full)
# add in planting block
F_m4 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population) + (1|PlantingBlock),
data = Full)
summary(F_m1)
summary(F_m2)
summary(F_m4)
anova(F_m1)
anova(F_m2)
anove(F_m4)
anova(F_m4)
Full_LSM <- summary(emmeans(F_m2, spec = "Population"))
View(Full_LSM)
# include block
Full2_LSM <- summary(emmeans(F_m4, spec = "Population"))
View(Full2_LSM)
# quick check correlation
cor(Full_LSM$emmean, Full2_LSM$emmean)
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean)
Full_RawMeans <- Full %>% group_by(Population) %>%
summarize(Full_PopFlwrMean = mean(NumShortStamens))
Seq_RawMeans <- Sequenced %>% group_by(Population) %>%
summarize(Seq_PopFlwrMean = mean(Short_Stamens))
# Create an output file (.ROBJ is good enough I think) with the Population, SSN, and elevation as metadata
Elev_Means <- merge(Full_RawMeans, Seq_RawMeans, by = "Population")
Elev_Means$Elev_m <- PopMetaData$Elev_m[match(Elev_Means$Population, PopMetaData$PopCode)]
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean)
View(Seq_LSM)
Seq_LSM <- summary(emmeans(S_m2, spec = "Population"))
View(S_m2)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
## create a fully nested random model
colnames(Sequenced)
# the important ones are Pop, Line, Rep, Tube to mimic what Jeff used
# Population
# line
# Rep
# Tube
# this doesn't include the flower b/c we want a mean
# full random model
S_m1 <- lmer(Short_Stamens ~ (1|Population) + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# full fixed model
S_m3 <- lm(Short_Stamens ~ Population + Line + Rep + Tube, data = Sequenced)
summary(S_m1)
summary(S_m2)
anova(S_m1)
anova(S_m2)
## create a fully nested random model
colnames(Sequenced)
# full random model
S_m1 <- lmer(Short_Stamens ~ (1|Population) + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# full fixed model
S_m3 <- lm(Short_Stamens ~ Population + Line + Rep + Tube, data = Sequenced)
summary(S_m1)
summary(S_m2)
anova(S_m1)
anova(S_m2)
Seq_LSM <- summary(emmeans(S_m2, spec = "Population"))
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean)
# let's see some correlations
cor.test(Comp$Full_PopFlwrMean, Comp$Full_LSM)
Comp <- merge(Elev_Means, LSMs, by = "Population")
# let's see some correlations
cor.test(Comp$Full_PopFlwrMean, Comp$Full_LSM)
cor.test(Comp$Full_PopFlwrMean, Comp$Full_Block)
cor.test(Comp$Full_LSM, Comp$Full_Block)
