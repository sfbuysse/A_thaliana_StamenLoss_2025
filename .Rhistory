ggplot(data = eigenVectors_noBOS) +
geom_jitter(mapping = aes(x = PC1, y = PC2, shape = Pop, fill = elev ), col = "black", size = 1.3, stroke = 0.5, height = 0.025, width = 0.025, show.legend = FALSE ) +
geom_hline(yintercept = 0, linetype="dotted") +
geom_vline(xintercept = 0, linetype="dotted") +
labs(x = paste0("PC 1 (",sprintf(pve_noBOS[1,1], fmt='%#.1f'),"%)"),
y = paste0("PC 2 (",sprintf(pve_noBOS[2,1], fmt='%#.1f'),"%)")) +
scale_shape_manual(name = "Population",
labels = unique(eigenVectors_noBOS$label),
values = c(22,21,24,23,25,22,21,24,25,22,21,24,23,25,22,21,24,23,25))+
scale_fill_gradientn(name = "Elevation", colours = topo.colors(16))+
theme_classic()+
theme(
legend.title = element_text(color = "black", size = 12),
legend.text = element_text(color = "black", size = 12),
axis.title = element_text(color = "black", size = 10),
axis.text = element_text(color = "black", size = 10),
legend.spacing.y = unit(0.03, "cm"))
ggsave(filename = "plink_PC1PC2_PlinkFiltering_noBOS_topo_fill.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs", height = 2.25, width = 2.25, device = "png", dpi = 700)
## topo fill PC3/PC4
ggplot(data = eigenVectors_noBOS) +
geom_jitter(mapping = aes(x = PC3, y = PC4, shape = Pop, fill = elev ), col = "black", size = 1.3, stroke = 0.5, height = 0.025, width=0.025, show.legend = FALSE ) +
geom_hline(yintercept = 0, linetype="dotted") +
geom_vline(xintercept = 0, linetype="dotted") +
labs(x = paste0("PC 3 (",sprintf(pve_noBOS[3,1], fmt='%#.1f'),"%)"),
y = paste0("PC 4 (",sprintf(pve_noBOS[4,1], fmt='%#.1f'),"%)")) +
scale_shape_manual(name = "Population",
labels = unique(eigenVectors_noBOS$label),
values = c(22,21,24,23,25,22,21,24,25,22,21,24,23,25,22,21,24,23,25))+
scale_fill_gradientn(name = "Elevation", colours = topo.colors(16))+
theme_classic()+
theme(
legend.title = element_text(color = "black", size = 12),
legend.text = element_text(color = "black", size = 12),
axis.title = element_text(color = "black", size = 10),
axis.text = element_text(color = "black", size = 10),
legend.spacing.y = unit(0.03, "cm"))
ggsave(filename = "plink_PC3PC4_PlinkFiltering_noBOS_topo_fill.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/supp", height = 2.25, width = 2.25, device = "png", dpi = 700)
##### plink filtering, no centromere #####
# barplot of PVE
ggplot(pve_noCent)+ geom_bar(aes(y = V1,x = PC), stat = "identity")
# nothing really notable.
# topo plots
## topo fill PC1/PC2
ggplot(data = eigenVectors_noCent) +
geom_jitter(mapping = aes(x = PC1, y = PC2, shape = Pop, fill = elev ), col = "black", size = 1.3, stroke = 0.5, height = 0.025, width = 0.025, show.legend = FALSE ) +
geom_hline(yintercept = 0, linetype="dotted") +
geom_vline(xintercept = 0, linetype="dotted") +
labs(x = paste0("PC 1 (",sprintf(pve_noCent[1,1], fmt='%#.f'),"%)"),
y = paste0("PC 2 (",sprintf(pve_noCent[2,1], fmt='%#.f'),"%)")) +
scale_shape_manual(name = "Population",
labels = unique(eigenVectors_noCent$label),
values = rep(c(22, 21, 24, 23, 25), times = 4))+
scale_fill_gradientn(name = "Elevation", colours = topo.colors(16))+
theme_classic()+
theme(
legend.title = element_text(color = "black", size = 12),
legend.text = element_text(color = "black", size = 12),
axis.title = element_text(color = "black", size = 10),
axis.text = element_text(color = "black", size = 10),
legend.spacing.y = unit(0.03, "cm"))
ggsave(filename = "plink_PC1PC2_PlinkFiltering_noCent_topo_fill.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/supp", height = 2.25, width = 2.25, device = "png", dpi = 700)
## topo fill PC1/PC2 labelled points to check out ALe-4 and compare to heterozygosity
ggplot(data = eigenVectors_noCent) +
geom_point(mapping = aes(x = PC1, y = PC2, shape = Pop, fill = elev ), col = "black", size = 4, stroke = 1, show.legend = FALSE ) + # was size = 3, stroke = 1.25 alpha = 0.7,
#geom_text(data = eigenVectors_noCent[eigenVectors_noCent$SeqID == "Ale-4", ], aes(x = PC1, y = PC2, label = SeqID), nudge_x = 0, nudge_y = +0.02, col = "black")+
geom_text(aes(x = PC1, y = PC2, label = SeqID), nudge_x = 0, nudge_y = +0.02, col = "black")+
geom_hline(yintercept = 0, linetype="dotted") +
geom_vline(xintercept = 0, linetype="dotted") +
labs(title = "PCA of Pyrenees Pops: Plink Filtering, No Centromere",
x = paste0("PC 1 (",sprintf(pve_noCent[1,1], fmt='%#.f'),"%)"),
y = paste0("PC 2 (",sprintf(pve_noCent[2,1], fmt='%#.f'),"%)")) +
scale_shape_manual(name = "Population",
labels = unique(eigenVectors_noCent$label),
values = rep(c(22, 21, 24, 23, 25), times = 4))+
scale_fill_gradientn(name = "Elevation", colours = topo.colors(16))+
theme_classic()+
theme(
legend.title = element_text(color = "black", size = 20),
legend.text = element_text(color = "black", size = 20),
axis.title = element_text(color = "black", size = 20),
axis.text = element_text(color = "black", size = 20),
legend.spacing.y = unit(0.03, "cm"))
ggsave(filename = "plink_PC1PC2_PlinkFiltering_noCent_topo_fill_labels.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures", height = 7, width = 7, device = "png", dpi = 500)
## topo fill PC3/PC4
ggplot(data = eigenVectors_noCent) +
geom_jitter(mapping = aes(x = PC3, y = PC4, shape = Pop, fill = elev ), col = "black", size = 1.3, stroke = 0.5, height = 0.025, width = 0.025, show.legend = FALSE ) +
#geom_text(aes(x = PC3, y = PC4, label = SeqID), nudge_x = 0, nudge_y = +0.02, col = "black")+
geom_hline(yintercept = 0, linetype="dotted") +
geom_vline(xintercept = 0, linetype="dotted") +
labs(x = paste0("PC 3 (",sprintf(pve_noCent[3,1], fmt='%#.1f')," %)"),
y = paste0("PC 4 (",sprintf(pve_noCent[4,1], fmt='%#.1f')," %)")) +
scale_shape_manual(name = "Population",
labels = unique(eigenVectors_noCent$label),
values = rep(c(22, 21, 24, 23, 25), times = 4))+
scale_fill_gradientn(name = "Elevation", colours = topo.colors(16))+
theme_classic()+
theme(
legend.title = element_text(color = "black", size = 12),
legend.text = element_text(color = "black", size = 12),
axis.title = element_text(color = "black", size = 10),
axis.text = element_text(color = "black", size = 10),
legend.spacing.y = unit(0.03, "cm"))
ggsave(filename = "plink_PC3PC4_PlinkFiltering_noCent_topo_fill.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/supp", height = 2.25, width = 2.25, device = "png", dpi = 700)
##### plink filtering, no centromere, no BOS #####
## topo fill PC1/PC2
ggplot(data = eigenVectors_noCent_noBOS) +
geom_jitter(mapping = aes(x = PC1, y = PC2, shape = Pop, fill = elev ), col = "black", size = 1.3, stroke = 0.5, height = 0.025, width = 0.025, show.legend = FALSE ) + # was size = 3, stroke = 1.25 alpha = 0.7,
geom_hline(yintercept = 0, linetype="dotted") +
geom_vline(xintercept = 0, linetype="dotted") +
labs(x = paste0("PC 1 (",sprintf(pve_noCent_noBOS[1,1], fmt='%#.1f'),"%)"),
y = paste0("PC 2 (",sprintf(pve_noCent_noBOS[2,1], fmt='%#.1f'),"%)")) +
scale_shape_manual(name = "Population",
labels = unique(eigenVectors_noCent_noBOS$label),
values = c(22,21,24,23,25,22,21,24,25,22,21,24,23,25,22,21,24,23,25))+
scale_fill_gradientn(name = "Elevation", colours = topo.colors(16))+
theme_classic()+
theme(
legend.title = element_text(color = "black", size = 12),
legend.text = element_text(color = "black", size = 12),
axis.title = element_text(color = "black", size = 10),
axis.text = element_text(color = "black", size = 10),
legend.spacing.y = unit(0.03, "cm"))
ggsave(filename = "plink_PC1PC2_PlinkFiltering_noCent_noBOS_topo_fill.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/supp", height = 2.25, width = 2.25, device = "png", dpi = 700)
## topo fill PC3/PC4
ggplot(data = eigenVectors_noCent_noBOS) +
geom_jitter(mapping = aes(x = PC3, y = PC4, shape = Pop, fill = elev ), col = "black", size = 1.3, stroke = 0.5, height = 0.025, width = 0.025, show.legend = FALSE ) + # was size = 3, stroke = 1.25 alpha = 0.7,
geom_hline(yintercept = 0, linetype="dotted") +
geom_vline(xintercept = 0, linetype="dotted") +
labs(x = paste0("PC 3 (",sprintf(pve_noCent_noBOS[3,1], fmt='%#.1f'),"%)"),
y = paste0("PC 4 (",sprintf(pve_noCent_noBOS[4,1], fmt='%#.1f'),"%)")) +
scale_shape_manual(name = "Population",
labels = unique(eigenVectors_noCent_noBOS$label),
values = c(22,21,24,23,25,22,21,24,25,22,21,24,23,25,22,21,24,23,25))+
scale_fill_gradientn(name = "Elevation", colours = topo.colors(16))+
theme_classic()+
theme(
legend.title = element_text(color = "black", size = 12),
legend.text = element_text(color = "black", size = 12),
axis.title = element_text(color = "black", size = 10),
axis.text = element_text(color = "black", size = 10),
legend.spacing.y = unit(0.03, "cm"))
ggsave(filename = "plink_PC3PC4_PlinkFiltering_noCent_noBOS_topo_fill.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/supp", height = 2.25, width = 2.25, device = "png", dpi = 700)
# set.seed for jitter
set.seed(656)
##### plink filtering test #####
# barplot of PVE
ggplot(pve_test)+ geom_bar(aes(y = V1,x = PC), stat = "identity")
# this looks more similar to the all.filtered output with higher values than the vcftools filtered file.
# TOPO graphs
# alpha (semi-transparency) not supported on HPCC (got a not supported on this device error)
# is using shape outline that is colored, don't use transparency at all. not actually sure I want it with fill either?
# make all graphs as both color and fill (no transparency), then decide later I think is the move... so many graphs...
#### topo color PC1/PC2
#ggplot(data = eigenVectors_test) +
#  geom_point(mapping = aes(x = PC1, y = PC2, shape = Pop, col = elev ), size = 3, stroke = 1.25, show.legend = FALSE ) + # was size = 3, #stroke = 1.25 alpha = 0.7,col = "black",
#  geom_hline(yintercept = 0, linetype="dotted") +
#  geom_vline(xintercept = 0, linetype="dotted") +
#  labs(title = "PCA of Pyrenees Pops: Plink Filtering",
#      x = paste0("Principal component 1 (",pve_test[1,1]," %)"),
#      y = paste0("Principal component 2 (",pve_test[2,1]," %)")) +
#  scale_shape_manual(name = "Population",
#                     labels = unique(eigenVectors_test$label),
#                     values = rep(c(0, 1, 2, 5, 6), times = 4))+ #c(22, 21, 24, 23, 25)
#  scale_color_gradientn(name = "Elevation", colours = topo.colors(16))+
#  theme_classic()+
#  theme(
#    legend.title = element_text(color = "black", size = 20),
#    legend.text = element_text(color = "black", size = 20),
#    axis.title = element_text(color = "black", size = 20),
#    axis.text = element_text(color = "black", size = 20),
#    legend.spacing.y = unit(0.03, "cm"))
#ggsave(filename = "plink_PC1PC2_PlinkFiltering_topo_color.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - #SophieAnalyses/Figures/ManuscriptFigs", height = 7, width = 7, device = "png", dpi = 500)
# topo fill PC1/PC2
ggplot(data = eigenVectors_test) +
geom_jitter(mapping = aes(x = -(PC1), y = PC2, shape = Pop, fill = elev ), col = "black", size = 1.3, stroke = 0.5, width = 0.025, height=0.025, show.legend = FALSE ) +
geom_hline(yintercept = 0, linetype="dotted") +
geom_vline(xintercept = 0, linetype="dotted") +
labs(x = paste0("PC 1 (",sprintf(pve_test[1,1], fmt='%#.1f'),"%)"),
y = paste0("PC 2 (",sprintf(pve_test[2,1], fmt='%#.1f'),"%)")) +
scale_shape_manual(name = "Population",
labels = unique(eigenVectors_test$label),
values = rep(c(22, 21, 24, 23, 25), times = 4))+
scale_fill_gradientn(name = "Elevation", colours = topo.colors(16))+
theme_classic()+
theme(
legend.title = element_text(color = "black", size = 12),
legend.text = element_text(color = "black", size = 12),
axis.title.y = element_text(color = "black", size = 10),
axis.title.x = element_text(color = "black", size = 10),
axis.text = element_text(color = "black", size = 10),
legend.spacing.y = unit(0.03, "cm"))
ggsave(filename = "plink_PC1PC2_PlinkFiltering_topo_fill.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs", height = 2.25, width = 2.25, device = "png", dpi = 700)
### topo color PC3/PC4
#ggplot(data = eigenVectors_test) +
#  geom_point(mapping = aes(x = PC3, y = PC4, shape = Pop, col = elev ), size = 3, stroke = 1.25, show.legend = FALSE ) + # was size = 3, #stroke = 1.25 alpha = 0.7,col = "black",
#  geom_hline(yintercept = 0, linetype="dotted") +
#  geom_vline(xintercept = 0, linetype="dotted") +
#  labs(title = "PCA of Pyrenees Pops: Plink Filtering",
#      x = paste0("Principal component 3 (",pve_test[3,1]," %)"),
#      y = paste0("Principal component 4 (",pve_test[4,1]," %)")) +
#  scale_shape_manual(name = "Population",
#                     labels = unique(eigenVectors_test$label),
#                     values = rep(c(0, 1, 2, 5, 6), times = 4))+ #c(22, 21, 24, 23, 25)
#  scale_color_gradientn(name = "Elevation", colours = topo.colors(16))+
#  theme_classic()+
#  theme(
#    legend.title = element_text(color = "black", size = 20),
#    legend.text = element_text(color = "black", size = 20),
#    axis.title = element_text(color = "black", size = 20),
#    axis.text = element_text(color = "black", size = 20),
#    legend.spacing.y = unit(0.03, "cm"))
#ggsave(filename = "plink_PC3PC4_PlinkFiltering_topo_color.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - #SophieAnalyses/Figures/ManuscriptFigs", height = 7, width = 7, device = "png", dpi = 500)
## topo fill PC3/PC4
ggplot(data = eigenVectors_test) +
geom_jitter(mapping = aes(x = PC3, y = PC4, shape = Pop, fill = elev ), col = "black", size = 1.3, stroke = 0.5, height = 0.025, width=0.025, show.legend = FALSE ) + # was size = 3, stroke = 1.25 alpha = 0.7,
geom_hline(yintercept = 0, linetype="dotted") +
geom_vline(xintercept = 0, linetype="dotted") +
labs(x = paste0("PC 3 (",sprintf(pve_test[3,1], fmt='%#.1f'),"%)"),
y = paste0("PC 4 (",sprintf(pve_test[4,1], fmt='%#.1f'),"%)")) +
scale_shape_manual(name = "Population",
labels = unique(eigenVectors_test$label),
values = rep(c(22, 21, 24, 23, 25), times = 4))+
scale_fill_gradientn(name = "Elevation", colours = topo.colors(16))+
theme_classic()+
theme(
legend.title = element_text(color = "black", size = 12),
legend.text = element_text(color = "black", size = 12),
axis.title = element_text(color = "black", size = 10),
axis.text = element_text(color = "black", size = 10),
legend.spacing.y = unit(0.03, "cm"))
ggsave(filename = "plink_PC3PC4_PlinkFiltering_topo_fill.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/supp", height = 2.25, width = 2.25, device = "png", dpi = 700)
##old plots
#ggplot(data = eigenVectors_test) +
#  geom_point(mapping = aes(x = PC1, y = PC2, color = Pop, shape = Pop ), size = 3, stroke = 1.25, show.legend = TRUE ) +
#  geom_hline(yintercept = 0, linetype="dotted") +
#  geom_vline(xintercept = 0, linetype="dotted") +
#  labs(title = "PCA of Pyrenees Pops: Plink Filtering",
#      x = paste0("Principal component 1 (",pve_test[1,1]," %)"),
#      y = paste0("Principal component 2 (",pve_test[2,1]," %)")) +
#  scale_shape_manual(name = "Population",
#                     labels = unique(eigenVectors_test$label),
#                     values = rep(c(0, 1, 2, 5), times = 4))+
#  scale_color_manual(name = "Population",
#                     labels = unique(eigenVectors_test$label),
#                     values = rep(c("red", "orange", "green", "blue"), times = c(4,4,4,4)))+
#  theme_classic()+
#  theme(
#    legend.title = element_text(color = "black", size = 12),
#    legend.text = element_text(color = "black", size = 10),
#    legend.spacing.y = unit(0.0001, "cm"))
#ggsave(filename = "plink_PC1PC2_PlinkFiltering.png", path = "/mnt/scratch/buysseso/PCA", height = 7, width = 9)
#
#ggplot(data = eigenVectors_test) +
#  geom_point(mapping = aes(x = PC3, y =PC4, col = Pop, shape = Pop), size = 3, stroke = 1.25, show.legend = TRUE ) +
#  geom_hline(yintercept = 0, linetype="dotted") +
#  geom_vline(xintercept = 0, linetype="dotted") +
#  labs(title = "PCA of Pyrenees Pops: Plink Filtering",
#      x = paste0("Principal component 3 (",pve_test[3,1]," %)"),
#      y = paste0("Principal component 4 (",pve_test[4,1]," %)")) +
#  scale_shape_manual(name = "Population",
#                     labels = unique(eigenVectors_test$label),
#                     values = rep(c(0, 1, 2, 5), times = 4))+
#  scale_color_manual(name = "Population",
#                     labels = unique(eigenVectors_test$label),
#                     values = rep(c("red", "orange", "green", "blue"), times = c(4,4,4,4)))+
#  theme_classic()+
#  theme(
#    legend.title = element_text(color = "black", size = 12),
#    legend.text = element_text(color = "black", size = 10),
#    legend.spacing.y = unit(0.0001, "cm"))
#ggsave(filename = "plink_PC3PC4_PlinkFiltering.png", path = "/mnt/scratch/buysseso/PCA", height = 7, width = 9)
##### plink, no BOS #####
# barplot of PVE
ggplot(pve_noBOS)+ geom_bar(aes(y = V1,x = PC), stat = "identity")
# looks decent, don't really know what to note.
#topo plots
## topo fill PC1/PC2
ggplot(data = eigenVectors_noBOS) +
geom_jitter(mapping = aes(x = -PC1, y = PC2, shape = Pop, fill = elev ), col = "black", size = 1.3, stroke = 0.5, height = 0.025, width = 0.025, show.legend = FALSE ) +
geom_hline(yintercept = 0, linetype="dotted") +
geom_vline(xintercept = 0, linetype="dotted") +
labs(x = paste0("PC 1 (",sprintf(pve_noBOS[1,1], fmt='%#.1f'),"%)"),
y = paste0("PC 2 (",sprintf(pve_noBOS[2,1], fmt='%#.1f'),"%)")) +
scale_shape_manual(name = "Population",
labels = unique(eigenVectors_noBOS$label),
values = c(22,21,24,23,25,22,21,24,25,22,21,24,23,25,22,21,24,23,25))+
scale_fill_gradientn(name = "Elevation", colours = topo.colors(16))+
theme_classic()+
theme(
legend.title = element_text(color = "black", size = 12),
legend.text = element_text(color = "black", size = 12),
axis.title = element_text(color = "black", size = 10),
axis.text = element_text(color = "black", size = 10),
legend.spacing.y = unit(0.03, "cm"))
ggsave(filename = "plink_PC1PC2_PlinkFiltering_noBOS_topo_fill.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs", height = 2.25, width = 2.25, device = "png", dpi = 700)
## topo fill PC3/PC4
ggplot(data = eigenVectors_noBOS) +
geom_jitter(mapping = aes(x = PC3, y = PC4, shape = Pop, fill = elev ), col = "black", size = 1.3, stroke = 0.5, height = 0.025, width=0.025, show.legend = FALSE ) +
geom_hline(yintercept = 0, linetype="dotted") +
geom_vline(xintercept = 0, linetype="dotted") +
labs(x = paste0("PC 3 (",sprintf(pve_noBOS[3,1], fmt='%#.1f'),"%)"),
y = paste0("PC 4 (",sprintf(pve_noBOS[4,1], fmt='%#.1f'),"%)")) +
scale_shape_manual(name = "Population",
labels = unique(eigenVectors_noBOS$label),
values = c(22,21,24,23,25,22,21,24,25,22,21,24,23,25,22,21,24,23,25))+
scale_fill_gradientn(name = "Elevation", colours = topo.colors(16))+
theme_classic()+
theme(
legend.title = element_text(color = "black", size = 12),
legend.text = element_text(color = "black", size = 12),
axis.title = element_text(color = "black", size = 10),
axis.text = element_text(color = "black", size = 10),
legend.spacing.y = unit(0.03, "cm"))
ggsave(filename = "plink_PC3PC4_PlinkFiltering_noBOS_topo_fill.png", path = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/supp", height = 2.25, width = 2.25, device = "png", dpi = 700)
# let's make a subset dataframe of the variables we are interested in
cor_test <- eigenVectors_test[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
cor_noBOS <- eigenVectors_noBOS[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
cor_noCent <- eigenVectors_noCent[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
cor_noCent_noBOS <- eigenVectors_noCent_noBOS[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
summary_test <- cor_test %>%
group_by(Pop) %>%
summarize("elev" = mean(elev), "lat" = mean(lat), "lon" = mean(lon), "PC1" = mean(PC1), "PC2" = mean(PC2), "PC3" = mean(PC3), "PC4" = mean(PC4))
round(cor(summary_test[ ,2:8]), 2)
PC1_geo <- lm(PC1 ~ elev + lat + lon, data = cor.test)
PC1_geo <- lm(PC1 ~ elev + lat + lon, data = summary_test)
summary(PC1_geo)
PC1_geo <- lm(PC1 ~ elev + lat + lon, data = summary_test)
summary(PC1_geo)
PC2_geo <- lm(PC2 ~ elev + lat + lon, data = summary_test)
summary(PC2_geo)
PC3_geo <- lm(PC3 ~ elev + lat + lon, data = summary_test)
summary(PC3_geo)
PC4_geo <- lm(PC4 ~ elev + lat + lon, data = summary_test)
summary(PC4_geo)
########## Visualize the Pixy results  ##########
library(dplyr)
library(ggplot2)
library(ggpubr)
load("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/PopGlobalPi_allsite_04082022.ROBJ")
### strong correlation. r = -0.801 p = 0.0001942
m.pi.elev <- lm(Mean.pi ~ Elev_m, data = comp)
### quadratic regression and look at both the linear and quadratic components of the model (coefficients)
### for quadratic regression
comp$Elev_m2 <- (comp$Elev_m)^2
m.ssn.elev <- lm(Full_PopFlwrMean ~ Elev_m + Elev_m2, data = comp)
#tmp <- lm(Full_PopFlwrMean ~ Elev_m + Elev_m2, data = comp)
#summary(tmp)
#
#tmp2 <- lm(Full_PopFlwrMean ~ Elev_m2 + Elev_m, data = comp)
#summary(tmp2)
#
#m.ssn.elev_3 <- lm(Full_PopFlwrMean ~ Elev_m + Elev_m2, data = comp, contrasts=list(Elev_m=contr.sum, Elev_m2=contr.sum))
#anova(m.ssn.elev) # this would be the default so it would be type I
#library(car)
#Anova(m.ssn.elev, type = 3)
comp$Elev_c2 <- (comp$Elev_m - mean(comp$Elev_m))^2
tmp4 <- lm(Full_PopFlwrMean ~ Elev_m + Elev_c2, data = comp)
# try just a linear fit to see if it matches Jeff's model
m.ssn.elev.linear <- lm(Full_PopFlwrMean ~ Elev_m, data = comp)
summary(tmp4)
summary(m.ssn.elev.linear)
summary(m.pi.elev)
### r = -0.2323357 p = 0.3865
m.pi.ssn <- lm(Seq_PopFlwrMean ~ Mean.pi, dat = comp)
summary(m.pi.ssn)
# adding this on later date. what about quadratic elevation predicting pi?
m.pi.elev2 <- lm(Mean.pi ~ Elev_m + Elev_c2, data = comp)
summary(m.pi.elev2)
# adding Jimmy's question of if quadratic nucleotide diveristy would get a better model
comp$pi_c2 <- (comp$Mean.pi - mean(comp$Mean.pi))^2
m.pi.ssn2 <- lm(Seq_PopFlwrMean ~ Mean.pi + pi_c2, dat = comp)
summary(m.pi.ssn2)
# adding squared pi
m.ssn.elev.pi2 <- lm(Seq_PopFlwrMean ~ Elev_m + Elev_c2 + Mean.pi + pi_c2, dat = comp)
summary(m.ssn.elev.pi2)
########## more complex model! ##########
### with cent ###
# this was done 10/26 with the cent included files and a centered quadratic model to reduce collinearity.
m.ssn.elev.pi.good <- lm(Seq_PopFlwrMean ~ Elev_m + Elev_c2 + Mean.pi, dat = comp)
summary(m.ssn.elev.pi.good)
# need to do a sequenced lines by elevation model to get the residuals from it.
tmp4_seq <- lm(Seq_PopFlwrMean ~ Elev_m + Elev_c2, data = comp)
plot(residuals(tmp4_seq))
# decently random when not coloring by anything
summary(tmp4_seq)
comp$Elev_residuals <- residuals(tmp4_seq) # index order matches row name order.
plot(comp$Elev_residuals, comp$Elev_m)
# now need to use the residuals in a plot - quick plot to start
plot(comp$Mean.pi, comp$Elev_residuals)
# there is maybe a positive relationship here?
# residuals range from -0.6 to 0.3
m.resid.pi2 <- lm(Elev_residuals ~ Mean.pi, dat = comp)
summary(m.resid.pi2)
# then I want the inverse. so the residuals of ssn ~ mean.pi regressed with elevation
# making new model b/c need order to match comp row order and I think it will but why not just do it again
tmp.resid2 <- residuals(lm(Seq_PopFlwrMean ~ Mean.pi, data = comp))
tmp.resid2
plot(tmp.resid2)
# look pretty random
comp$Pi_residuals <- tmp.resid2
plot(comp$Elev_m, comp$Pi_residuals)
# not great, but doesn't include the quadratic term. Here I kinda see two curves
m.resid.elev2 <- lm(Pi_residuals ~ Elev_m + Elev_c2, dat = comp)
summary(m.resid.elev2)
########## AIC scores ##########
AIC(m.pi.elev)
AIC(m.pi.elev2)
AIC(m.ssn.elev.linear)
AIC(tmp4)
AIC(m.pi.ssn)
AIC(m.pi.ssn2)
AIC(m.ssn.elev.pi.good)
AIC(m.ssn.elev.pi2)
AIC(tmp4_seq)
AIC(m.resid.pi2)
AID(m.resid.elev2)
AIC(m.resid.elev2)
knitr::opts_chunk$set(echo = TRUE)
#' Calculate Qpc
#'
#' This function calculates Qpc given data about the relatedness matrix, and a set of trait values
#' @param myZ vector of traits. Not normalized yet.
#' @param myU matrix of eigenvectors of the kinship matrix (each column is an eigenvector)
#' @param myLambdas vector of eigenvalues of the kinship matrix
#' @param myM the range of PCs you want to test for selection
#' @param myL the range of PCs used to estimate Va
#' @export
#' @examples
#' calcQpc()
calcQpc <- function(myZ, myU, myLambdas, myL, myM){
myZ = myZ[1:dim(myU)[1]] - mean(myZ) #mean center phenotypes
myCmM = (myZ %*% myU[,myM])/sqrt(myLambdas[myM]) #project + standardize by the eigenvalues for testing for selection
myCmL = (myZ %*% myU[,myL])/sqrt(myLambdas[myL]) #project + standardize by the eigenvalues for estimating Va
myQm = sapply(myM, function(n){var0(myCmM[n])/var0(myCmL) })  #test for selection
myPs = sapply(myM, function(x){pf(myQm[x], 1, length(myL), lower.tail=F)}) #get a pvalue
retdf = list(cm = myCmM, cml = myCmL, qm = myQm, pvals = myPs)
return(retdf)
}
#' Calculate conditional Qpc
#'
#' This function calculates Qpc given data about the relatedness matrix, and a set of trait values
#' @param myZ two columned data frame containing vectors of two traits. Not normalized yet. The first trait is the one we're testing for selection on conditional on the second trait.
#' @param myU matrix of eigenvectors of the kinship matrix (each column is an eigenvector)
#' @param myLambdas vector of eigenvalues of the kinship matrix
#' @param myM the range of PCs you want to test for selection
#' @param myL the range of PCs used to estimate Va
#' @export
#' @examples
#' calcQpc()
condQpc <- function(myZ,myU, myLambdas, myM, myL){
# get Xms for each PC (for Z1, the focal trait and Z2, the correlated trait) THESE ARE MEAN CENTERED
myX1centered = (myZ[-nrow(myZ),1]-mean(myZ[,1]))%*%myU/sqrt(myLambdas)
myX2centered = (myZ[-nrow(myZ),2]-mean(myZ[,2]))%*%myU/sqrt(myLambdas)
#get mu' for each PC
Ca12 = sum(myX1centered[myL]*myX2centered[myL])/length(myL) #is this the right way to do this??
Va2 = (sum(myX2centered[myL]^2))/length(myL)
Va1 = sum(myX1centered[myL]^2)/length(myL)
mu1cond = mean(myZ[-nrow(myZ),1]) + (Ca12/Va2)*(myZ[-nrow(myZ),2] - mean(myZ[,2])) #one value for each individual
va1cond = Va1 - (Ca12^2)/Va2
#now test for selection
myQ = ((myZ[-nrow(myZ),1]-mu1cond)%*%myU[,myM])/sqrt(myLambdas[myM]*va1cond) #get a vector of the projections that we'll test
#under neutrality, my Q ~ N(0,1)
return(myQ)
}
#' Kinship matrix function for complete data using the estimated variance across all loci
#'
#' This function makes a kinship matrix using the cov function. It standardizes by the estimated genic variance across all loci, not each locus individually
#' @param myG matrix where the rows are individuals/populations and the columns are loci and the values are the allele frequency (not the # of copies present in an individual!!!).
#' @export
make_k <- function (myG)
{
scaleFactor = sqrt(mean(colMeans(myG) * (1 - colMeans(myG))))
myM = dim(myG)[1]
myT = matrix(data = -1/myM, nrow = myM - 1, ncol = myM)
diag(myT) = (myM - 1)/myM
myGstand = (myT %*% myG)/scaleFactor
myK = cov(t(myGstand))
return(myK)
}
#' Calculate variance where the mean is set to zero
#'
#' This function takes a string of numbers and calculates the variance of these numbers, assuming that the mean is 0.
#' @param x a string of vectors
#' @export
var0 <- function(x){  #variance where mean is set to 0
return(sum(x^2)/length(x))
}
library(viridis)
library(ggplot2)
# my data!
# load in my data - I think this is actually the wrong data. I want the numeric format data not the letter format data.
# genotype Matrix of 50K randomly chosen sites (see 10_QpcPrep)
load("data/GenotypeMatrix_Cent_50k_Nov2023.ROBJ") # called Stamen_Gt_sub
load("data/RawPhenotypes_Aug2023.ROBJ") # called pheno2
# don't have any missing phenotype data to get rid of
# let's join geno and pheno together quickly
stamenCombined <- dplyr::inner_join(Stamen_Gt_sub, pheno2, by = 'LineID')
# make stamenG to use for make_k
stamenG <- stamenCombined[ , c(2:50001)]
# make list of phenotype, basically replicates pheno2 but this way I know the orders will be the same with the geno matrix
stamenTrait <- stamenCombined[ , c(1, 50002)]
# Stamen Data
stamenK <- make_k(as.matrix(stamenG))
# do eigen decomposition
stamenEig <- eigen(stamenK)
# plot the first two PCs
plot(stamenEig$vectors[,1], stamenEig$vectors[,2], bty="n", xlab = "PC1", ylab = "PC2", col = '#FF5300')
# this looks different than the PCA I made with plink, likely just because the standardization is different??
# plot pve
plot(stamenEig$values/sum(stamenEig$values)*100, col = "#43B629", bty="n", ylab = "% variation explained by each PC", xlab = "PC")
# PVE of PCs
stamenEig$values/sum(stamenEig$values)*100
