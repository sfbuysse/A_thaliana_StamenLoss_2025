forplot$bon <- p.adjust(forplot$P, method = "bonferroni")
# add row for outlining shared SNPs
forplot$shared <- as.character(alpha(forplot$fdr_col, 0))
forplot[forplot$SNP %in% type, "shared"] <- alpha("green", 1)
forplot$shared <- as.factor(forplot$shared)
###### manual plot #####
# prep to plot
don <- forplot %>%
# compute chromosome size in bp
group_by(CHR) %>%
summarize(chr_len=max(BP)) %>%
#calculate cumulative position of each chromosome (again in bp)
mutate(tot=cumsum(chr_len)-chr_len) %>%
dplyr::select(-chr_len) %>%
#add this info to the initial data set (so like adding new column and sorting by it)
left_join(forplot, ., by=c("CHR"="CHR")) %>%
#add cum position of each SNP
arrange(CHR, BP) %>%
mutate( psCum=BP+tot)
axisdf = don %>% group_by(CHR) %>% summarize(center=( max(psCum) + min(psCum) ) /2 )
#sig.level is set in the function line. is 0.05 default but not expecting hits above that.
bonferroni_sig <- sig.level/length(forplot$P)
# and plot. should just make the 1 plot.
# split don into shared SNPs and not shared SNPs, then merging together so the shared snps are at the bottom of the dataframe and will be plotted on top of the other points.
don_a <- don[don$shared == "#00FF00FF", ]
don_b <- don[don$shared != "#00FF00FF", ]
don_c <- rbind(don_b, don_a)
# start plot with don_b becuase that is most of what I'll need
m_plot <- ggplot(don_c, aes(x=psCum, y=-log10(P))) +
geom_point(aes(fill = fdr_col, color = shared), shape = 21, size = 1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "#FFC107", linetype = "dashed", alpha = 0.6)+
geom_segment(aes(x = 21551000, y = -0.3, xend = 30245000, yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x = (50122495+7329000), y = -0.3, xend = (50122495+ 8201000), yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x =(92167091+2408000 ), y = -0.3, xend = (92167091+2986000 ), yend = -0.3), col = "black", lineend = "round")+
scale_fill_manual(values = alpha(levels(don_c$fdr_col),0.8)) +
scale_color_manual(values = levels(don_c$shared))+
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= bquote(-log[10](p)))+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
## merge manhattan and qq into a single thing??
# this doesn't work as written because the ggplot is a grid object and the qqplot is not a grid object, so issues ensue.
#qqplot <- qqman::qq(forplot$P)
## would need the package that let's me make multi facet figures
## then set 2/3 or 3/4 spaces as mplot, and one as qq, then save the merged file
#final_fig <- ggarrange(m_plot, qqplot, nrow = 1, ncol = 2, widths = c(2,1))
##ggplot(forplot, aes(sample = P)+
##geom_qq()+
##geom_qq_line()+
##  labs(x = "Expected", y = "Observed")+
##  theme_bw()
ggsave(paste0(fig_name,".png"), plot = m_plot, width = 7, height = 3, dpi = 700, units = "in")
print(paste0("Done making plot for: ", identifier))
}
# going with this for now (11/3/2023) but I do think I could plot the shared ones as a second layer and then they would all be on the top rather than covered by some other points.
# there might also be a slighly overlap between color and fill that is creating a dark outline because both are at least somewhat transparent. Maybe I need to decrease size so it isn't 1.3?
##### Raw Phenotypes #####
manhattan_highlight(identifier = "allSNPs.PlinkFiltering_raw.c", type = cent)
##### Subset Raw Phenotypes #####
# only include if less than 2 as mean short stamen number
manhattan_highlight(identifier = "allSNPs.PlinkFiltering_raw_subset.c", type = cent)
##### Asin Phenotypes #####
manhattan_highlight(identifier = "allSNPs.PlinkFiltering_Asin.c", type = cent)
##### Binary Phenotypes #####
manhattan_highlight(identifier = "allSNPs.PlinkFiltering_Binary.c", type = cent)
##### Elevation! #####
manhattan_highlight(identifier = "allSNPs.PlinkFiltering_Elev.c", type = cent)
knitr::opts_chunk$set(echo = TRUE)
library(praise)
##### do it time 3 #####
# read in top hits file
#top_hits_fdr_all <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/Top_hits_fdr_wald_Apr2023.csv")
top_hits_fdr_all <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/Top_hits_fdr_wald_Apr2023.csv")
#make a 1000bp window centered on the SNP
top_hits_fdr_all$min <- top_hits_fdr_all$ps - 500
top_hits_fdr_all$max <- top_hits_fdr_all$ps + 500
### things that happen to all chromosomes at once ###
# take out elevation for now and see if that increases the workability of my loop output
# problem with this code is that it gets rid of any row that has a value for elev even if it overlaps with a different one, so maybe just get rid of that column? but I really need to reduce rows to get an easier to read output... hm how to do this
# maybe I need to do it in two steps. first step would be to get rid of the columns, second step would be to get rid of rows that are all NAs
th_fdr_noelev <- top_hits_fdr_all[, grep("elev", colnames(top_hits_fdr_all), value = TRUE, invert = TRUE)]
# maybe to solve the problem of making sure the overlap is between two GWAS types, I should also only look at either all or NoCent at once
# using the 'inverse of all' code so the first three columns are also kept
th_noelev_nocent <- top_hits_fdr_all[, grep("all", colnames(th_fdr_noelev), value = TRUE, invert = TRUE)]
# using the 'inverse of nocent' code so the first three columns are also kept
th_noelev_all <- top_hits_fdr_all[, grep("nc", colnames(th_fdr_noelev), value = TRUE, invert = TRUE)]
# adding elevation back in on 1/25/2024 because I need the overlap analysis to be consistent between everything.
# using the "inverse of all' code so the first three columns are kept + min + max
th_nocent <- top_hits_fdr_all[, grep("all", colnames(top_hits_fdr_all), value = TRUE, invert = TRUE)]
# using the 'inverse of nocent' code so the first three columns are also kept
th_all <- top_hits_fdr_all[, grep("nc", colnames(top_hits_fdr_all), value = TRUE, invert = TRUE)]
# so count NAs, and  keep rows with fewer than 12 NAs (3 columns should have values for all rows)
th_noelev_nocent <- th_noelev_nocent[rowSums(is.na(th_noelev_nocent)) < 12 , ]
# sample size went way down!
th_noelev_all <- th_noelev_all[rowSums(is.na(th_noelev_all)) < 12 , ]
# sample size went way down! but is larger than no cent.
# so count NAs, and  keep rows with fewer than 15 NAs (5 columns should have values for all rows)
# expect this to reduce rows that were only in all or only in nocent now that I've split them up.
th_nocent <- th_nocent[rowSums(is.na(th_nocent)) < 15 , ]
# sample size went down by ~2000
th_all <- th_all[rowSums(is.na(th_all)) < 15 , ]
# sample size went down by ~3000
## trouble shooting note: 5:13458838 still exists in the dataset at this point in time. SO I do think the issue is in the id_snps function requires at least 2 overlapping SNPs.
#### Functions ####
# nested loops that give me an output that is a list of dataframes with at least 2 overlapping SNPs in the window
# after commenting out and testing on chromosome 5, it did keep the 1 SNP I had identified that should have been included and wasn't previously (5:13458838) which I think is a good sign, and the second function really cut down the included windows enough so I am going to commit, then remove the commented out lines from  the id_snps function that filter for only having 2+ rows because I don't need them anymore
id_snps <- function(input){
output <- list()
len <- length(input$ps) # to this point works
# loop that makes a list of all SNPs in the window
for (i in c(1:len)){
tmp_list <- c(input$min[i]:input$max[i])
tmp_df <- data.frame()
# loop that checks if snps in the dataframe are in the list of all SNPs in the window
for (j in c(1:len)){
if (input$ps[j] %in% tmp_list) {
tmp_df <- rbind(tmp_df, input[j, ])}
}
# add new dataframe to a list of dataframes to be in the output
output <- append(output, list(tmp_df))
}
return(output)
}
#testing123 <- id_snps(hits_fdr_chr1)
#identical(testing123, chr1_overlap_nc)
## celebrate!
#praise()
# function to identify if any of the overlapping regions are between at least 2 GWAS types
# issue with this function is that the columns to check will change depending on if it is an nc file or an all file
# I think this function might actually need a bit more testing
#nc_p_cols <- c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")
#all_p_cols <- c("p_binary_all", "p_raw_all", "p_asin_all", "p_subset_all")
# include elev
nc_p_cols <- c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc", "p_elev_nc")
all_p_cols <- c("p_binary_all", "p_raw_all", "p_asin_all", "p_subset_all", "p_elev_all")
gwas_overlap <- function(input, keep_cols){
cols_with_values <- c()
for(d in c(1:length(input))){
cols_with_values[d] <- sum(colSums(is.na(input[[d]][,keep_cols])) < length(input[[d]][ ,1]))
}
# then write out the dataframes from the initial list
output <- input[c(cols_with_values > 1)]
return(output)
}
##testing further below, but it seems to work!
praise()
#### chr 1 ####
##### no cent #####
# only keep the p value columns
hits_fdr_chr1 <- th_noelev_nocent[(th_noelev_nocent$chr == 1), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr1_overlap_nc <- id_snps(hits_fdr_chr1)
# now that my sample size is larger, this output is kinda ridiculous to go through by hand. So I want to add something that will make sure it is at least two different types of gwas I think (instead of a bunch of hits in binary that are overlapping which I do see now)
# the bigger concern might actually be trying to not have the duplicate outputs
# output makes more sense when ran in the console
# successfully make an output that is a list of dataframes! This still has 227 entries, so how to go through that with code? Wait, why do i and j end at 344 and not at 2452? I'm still worried something is wrong... quick try the loop without the second if statement. still only 344 elements in the list now but it should be all of them. oh I'm spacing out. 344 is everything from chromosome 1. so no real problem here, I was just being silly.
length(unique(chr1_overlap_nc)) # only 115 are unique, that seems promising; 232 unique when keeping tmp_df with only one row (i.e., one SNP)
# when I was only keeping locations with at least 3 SNPs, there were only 74 unique but: it is just the first 74 though and that seems odd
# chr1_overlap_nc[[75]] # I did manually find this in the unique output. manually checked: 75, 100, 104, 118, 145, 87 and found duplicates for all of them!
# do I still need to go through the unique value by hand then to figure out if multiple GWAS are overlapping? I feel like I should be able to write code to see if 3 of thefour gwas columns are NA and get rid of those, but keep if only 2 or fewer of the columns are NAs
# first step - subset to just be evaluating the p values rows
# if 3 are only NAs - delete
# if less than three are only NAs - keep
# problem with this is that the code checks by row, so this would require a single SNP to show up in multiple which is not what I want
# so I don't think I can use rowSums because I don't want the row aspect of requiring it to be a single SNP.
# I can use colSums. and then I want to keep any data frame where 2 of the columns have colSums less than the number of rows in that dataframe.
# okay so I got it so I get the sum of columns that are not fully NAs. Then I only want to keep the whole dataframe if that sum is greater than 1. how do I do that part? so maybe I should first just make a list of the sums for each dataframe in my list of dataframes.
# don't expect this to keep any
OverlapHits_chr1_nc <- gwas_overlap(chr1_overlap_nc, nc_p_cols)
#### chr 1 ####
##### no cent #####
# only keep the p value columns
hits_fdr_chr1 <- th_noelev_nocent[(th_noelev_nocent$chr == 1), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr1_overlap_nc <- id_snps(hits_fdr_chr1)
length(unique(chr1_overlap_nc)) # only 115 are unique, that seems promising; 232 unique when keeping tmp_df with only one row (i.e., one SNP)
# don't expect this to keep any
OverlapHits_chr1_nc <- gwas_overlap(chr1_overlap_nc, nc_p_cols)
nc_p_cols <- c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")
all_p_cols <- c("p_binary_all", "p_raw_all", "p_asin_all", "p_subset_all")
#### chr 1 ####
##### no cent #####
# only keep the p value columns
hits_fdr_chr1 <- th_noelev_nocent[(th_noelev_nocent$chr == 1), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr1_overlap_nc <- id_snps(hits_fdr_chr1)
# now that my sample size is larger, this output is kinda ridiculous to go through by hand. So I want to add something that will make sure it is at least two different types of gwas I think (instead of a bunch of hits in binary that are overlapping which I do see now)
# the bigger concern might actually be trying to not have the duplicate outputs
# output makes more sense when ran in the console
# successfully make an output that is a list of dataframes! This still has 227 entries, so how to go through that with code? Wait, why do i and j end at 344 and not at 2452? I'm still worried something is wrong... quick try the loop without the second if statement. still only 344 elements in the list now but it should be all of them. oh I'm spacing out. 344 is everything from chromosome 1. so no real problem here, I was just being silly.
length(unique(chr1_overlap_nc)) # only 115 are unique, that seems promising; 232 unique when keeping tmp_df with only one row (i.e., one SNP)
# when I was only keeping locations with at least 3 SNPs, there were only 74 unique but: it is just the first 74 though and that seems odd
# chr1_overlap_nc[[75]] # I did manually find this in the unique output. manually checked: 75, 100, 104, 118, 145, 87 and found duplicates for all of them!
# do I still need to go through the unique value by hand then to figure out if multiple GWAS are overlapping? I feel like I should be able to write code to see if 3 of thefour gwas columns are NA and get rid of those, but keep if only 2 or fewer of the columns are NAs
# first step - subset to just be evaluating the p values rows
# if 3 are only NAs - delete
# if less than three are only NAs - keep
# problem with this is that the code checks by row, so this would require a single SNP to show up in multiple which is not what I want
# so I don't think I can use rowSums because I don't want the row aspect of requiring it to be a single SNP.
# I can use colSums. and then I want to keep any data frame where 2 of the columns have colSums less than the number of rows in that dataframe.
# okay so I got it so I get the sum of columns that are not fully NAs. Then I only want to keep the whole dataframe if that sum is greater than 1. how do I do that part? so maybe I should first just make a list of the sums for each dataframe in my list of dataframes.
# don't expect this to keep any
OverlapHits_chr1_nc <- gwas_overlap(chr1_overlap_nc, nc_p_cols)
# and it didn't which for this case is a good sign because it is what I was expecting. see below for all of my testing code.
# manually scrolling through, all of the overlap just with nocent is only within a single gwas type... what changed? some hits must not have made the cutoff.
#maybe try it on all instead of NC?
##### all  #####
# only keep the p value columns
hits_fdr_chr1_a <- th_noelev_all[(th_noelev_all$chr == 1), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr1_overlap_all <- id_snps(hits_fdr_chr1_a)
# This has 279 entries
length(unique(chr1_overlap_all)) # only 133 are unique with 2+ SNPs, 285 are unique with at least one SNP
# manually checked the places where I had overlap with the top 50, and what seems to have changed in the 2243xxxx region is that those SNPS didn't make the cutoff for the subset analysis, so they are not included and my overlap has disappeared.
OverlapHits_chr1_all <- gwas_overlap(chr1_overlap_all, all_p_cols)
# start shared snps list
shared_snps <- unique(c(OverlapHits_chr1_all[[1]]$rs))
##### no cent #####
# only keep the p value columns
hits_fdr_chr2 <- th_noelev_nocent[(th_noelev_nocent$chr == 2), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr2_overlap_nc <- id_snps(hits_fdr_chr2)
#271 elements
length(unique(chr2_overlap_nc)) # 103 unique, 210 when including windows with only 1 SNP
# check for overlap between gwas types
OverlapHits_chr2_nc <- gwas_overlap(chr2_overlap_nc, nc_p_cols)
# empty list :(
##### all  #####
# only keep the p value columns
hits_fdr_chr2_a <- th_noelev_all[(th_noelev_all$chr == 2), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr2_overlap_all <- id_snps(hits_fdr_chr2_a) # 306 elements
length(unique(chr2_overlap_all)) # 118 are unique, 244 are unique when including windows with only 1 SNP
# fancy function 2
OverlapHits_chr2_all <- gwas_overlap(chr2_overlap_all, all_p_cols)
# empty list
##### no cent #####
# only keep the p value columns
hits_fdr_chr3 <- th_noelev_nocent[(th_noelev_nocent$chr == 3), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr3_overlap_nc <- id_snps(hits_fdr_chr3)
#628 elements, 826 when keeping one SNP windows
length(unique(chr3_overlap_nc)) # 272 unique, 470 unique when keeping one SNP windows
# check for overlap between gwas types
OverlapHits_chr3_nc <- gwas_overlap(chr3_overlap_nc, nc_p_cols)
# keeps 3 when keeping windows with only one SNP (none if require 2 SNPs)
##### all  #####
# only keep the p value columns
hits_fdr_chr3_a <- th_noelev_all[(th_noelev_all$chr == 3), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr3_overlap_all <- id_snps(hits_fdr_chr3_a) # 758 elements
length(unique(chr3_overlap_all)) # 328 are unique, 581 unique when keeping 1 SNP windows
# fancy function 2
OverlapHits_chr3_all <- gwas_overlap(chr3_overlap_all, all_p_cols)
# list of 3, the same as the ones that show up with nc
# add to shared snps list
shared_snps <- append(shared_snps, unique(c(OverlapHits_chr3_all[[1]]$rs, OverlapHits_chr3_all[[2]]$rs, OverlapHits_chr3_all[[3]]$rs)))
shared_snps
##### no cent #####
# only keep the p value columns
hits_fdr_chr4 <- th_noelev_nocent[(th_noelev_nocent$chr == 4), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr4_overlap_nc <- id_snps(hits_fdr_chr4)
#only 36! 64 when including 1 SNP windows
length(unique(chr4_overlap_nc)) # 17 unique, 45 with 1 SNP windows
# check for overlap between gwas types
OverlapHits_chr4_nc <- gwas_overlap(chr4_overlap_nc, nc_p_cols)
# empty list :(
##### all  #####
# only keep the p value columns
hits_fdr_chr4_a <- th_noelev_all[(th_noelev_all$chr == 4), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr4_overlap_all <- id_snps(hits_fdr_chr4_a) # 43 elements (82 with 1 SNP windows)
length(unique(chr4_overlap_all)) # 16 are unique (55 unique with 1 SNp windows)
# fancy function 2
OverlapHits_chr4_all <- gwas_overlap(chr4_overlap_all, all_p_cols)
# empty list
View(OverlapHits_chr3_all)
##### no cent #####
# only keep the p value columns
hits_fdr_chr5 <- th_noelev_nocent[(th_noelev_nocent$chr == 5), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr5_overlap_nc <- id_snps(hits_fdr_chr5)
#624 elements! (840 with 1 SNP windows)
length(unique(chr5_overlap_nc))
# 278 unique that have 2+ SNPs - wow that cut down a lot
# 494 unique without the filtering for 2+ SNPs. so does this mean there are only 494 unique windows out of 840? I guess I'm not entirely sure what this means right now.
# check for overlap between gwas types
OverlapHits_chr5_nc <- gwas_overlap(chr5_overlap_nc, nc_p_cols)
# list of 8 that have 2+ SNPs!
# list of 11 that have at least 1 SNP - includes the 8 from before plus 3 earlier in the chromosome
##### all  #####
# only keep the p value columns
hits_fdr_chr5_a <- th_noelev_all[(th_noelev_all$chr == 5), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr5_overlap_all <- id_snps(hits_fdr_chr5_a) #  1191 elements - something going on in this centromere (1505 with 1 SNP windows)
length(unique(chr5_overlap_all)) # 602 are unique ( 916 unique with 1 SNP windows)
# fancy function 2
OverlapHits_chr5_all <- gwas_overlap(chr5_overlap_all, all_p_cols)
# list of 11!
# list of 13 when including 1 SNP windows. which means all only added 2 new windows but nc added 3. hmm.
# add to list of all the SNPs overlapping at all here to highlight in a GWAS figure.
shared_snps <- append(shared_snps, unique(c(OverlapHits_chr5_all[[1]]$rs, OverlapHits_chr5_all[[2]]$rs, OverlapHits_chr5_all[[3]]$rs, OverlapHits_chr5_all[[4]]$rs, OverlapHits_chr5_all[[5]]$rs, OverlapHits_chr5_all[[6]]$rs, OverlapHits_chr5_all[[7]]$rs, OverlapHits_chr5_all[[8]]$rs, OverlapHits_chr5_all[[9]]$rs, OverlapHits_chr5_all[[10]]$rs, OverlapHits_chr5_all[[11]]$rs, OverlapHits_chr5_all[[12]]$rs, OverlapHits_chr5_all[[13]]$rs, OverlapHits_chr5_nc[[1]]$rs, OverlapHits_chr5_nc[[2]]$rs, OverlapHits_chr5_nc[[3]]$rs, OverlapHits_chr5_nc[[4]]$rs, OverlapHits_chr5_nc[[5]]$rs, OverlapHits_chr5_nc[[6]]$rs, OverlapHits_chr5_nc[[7]]$rs, OverlapHits_chr5_nc[[8]]$rs, OverlapHits_chr5_nc[[9]]$rs, OverlapHits_chr5_nc[[10]]$rs, OverlapHits_chr5_nc[[11]]$rs)))
shared_snps
View(OverlapHits_chr5_nc)
View(OverlapHits_chr5_all)
OverlapHits_chr5_all[[5]][["ps"]]
OverlapHits_chr5_all[[6]][["ps"]]
OverlapHits_chr5_all[[7]][["ps"]]
OverlapHits_chr5_all[[8]][["ps"]]
OverlapHits_chr5_all[[9]][["ps"]]
library(ggplot2)
library(dplyr)
library(qqman)
library(ggpubr)
rm(list = ls())
# list of files to read in :
files <- c("NoCent.PlinkFiltering_Binary.c", "NoCent.PlinkFiltering_raw.c",  "NoCent.PlinkFiltering_Asin.c", "NoCent.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Asin.c", "allSNPs.PlinkFiltering_raw.c", "allSNPs.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Binary.c", "allSNPs.PlinkFiltering_raw_subset.c", "NoCent.PlinkFiltering_raw_subset.c","NoCent.PlinkFiltering_raw.c_testing" )
# list of shared SNPs - there are two lists for hits shared between cent included analyses and between cent excluded analyses with no overlap of the SNPs that are a hit in cent and no cent for the same type of GWAS - there is 1 hit window only in cent and a different one only in no cent
# Cent only shared snps
# on 1/29/2024 I remade these figures because I had only been including SNPs where the exact SNP was >0.10 in both analyses and ignoring the whole windowed analysis thing that I did. So a few more SNPs to highlight!
cent <- c("Chr1:14262517",
"Chr3:2239234",
"Chr3:2253161",
"Chr3:2942726",
"Chr5:4899729",
"Chr5:4899733",
"Chr5:4899789",
"Chr5:4899798",
"Chr5:4899803",
"Chr5:4899865",
"Chr5:4900275",
"Chr5:4900560",
"Chr5:4900628",
"Chr5:4919727",
"Chr5:4920179",
"Chr5:4920289",
"Chr5:4920304",
"Chr5:4920731",
"Chr5:10731997",
"Chr5:13458838"
)
# no cent only shared SNPs
nocent <- c("Chr3:2239234",
"Chr3:2253161",
"Chr3:2942726",
"Chr5:4899789",
"Chr5:4899798",
"Chr5:4899803",
"Chr5:4900275",
"Chr5:4900560",
"Chr5:4919727",
"Chr5:4920179",
"Chr5:4920289",
"Chr5:4920304",
"Chr5:4920731",
"Chr5:10731997",
"Chr5:13458838",
"Chr5:19462189"
)
# for testing
#identifier <- "allSNPs.PlinkFiltering_asin.c"
#identifier <- "allSNPs.PlinkFiltering_Elev.c"
#sig.level <- 0.05
manhattan_highlight <- function(identifier, sig.level = 0.05, type){
# add fdr.line as an object?
##### Set filenames and read in file #####
filename = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/", identifier, ".assoc.txt")
fig_name = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/", identifier)
results <- read.delim(file= filename, header = T, stringsAsFactors = F)
# reorganize dataframe
forplot <- data.frame("BP" = results$ps, "CHR" = results$chr, "P" = results$p_wald, "SNP" = results$rs)
forplot$fdr <- p.adjust(p= forplot$P, method = "fdr")
#for point color...
forplot$fdr_col <- forplot$CHR
forplot[forplot$fdr_col == 1, "fdr_col"] <- "#ABABAB"
forplot[forplot$fdr_col == 2, "fdr_col"] <- "#000000"
forplot[forplot$fdr_col == 3, "fdr_col"] <- "#ABABAB"
forplot[forplot$fdr_col == 4, "fdr_col"] <- "#000000"
forplot[forplot$fdr_col == 5, "fdr_col"] <- "#ABABAB"
forplot[forplot$fdr < 0.10, "fdr_col"] <- "#1E88E5"
# allSNPs raw: cutoff for this is between 9.651559e-02 (6) and 1.004850e-01 (1)
forplot[forplot$fdr < 0.05, "fdr_col"] <- "#D66C93"
# allSNPs raw: cutoff for this is between 7.323552e-02 (6) and 4.269675e-03(7)
forplot$fdr_col <- as.factor(forplot$fdr_col)
#make the shared hits a 0 or something??
# add bonferroni correction p value
forplot$bon <- p.adjust(forplot$P, method = "bonferroni")
# add row for outlining shared SNPs
forplot$shared <- as.character(alpha(forplot$fdr_col, 0))
forplot[forplot$SNP %in% type, "shared"] <- alpha("green", 1)
forplot$shared <- as.factor(forplot$shared)
###### manual plot #####
# prep to plot
don <- forplot %>%
# compute chromosome size in bp
group_by(CHR) %>%
summarize(chr_len=max(BP)) %>%
#calculate cumulative position of each chromosome (again in bp)
mutate(tot=cumsum(chr_len)-chr_len) %>%
dplyr::select(-chr_len) %>%
#add this info to the initial data set (so like adding new column and sorting by it)
left_join(forplot, ., by=c("CHR"="CHR")) %>%
#add cum position of each SNP
arrange(CHR, BP) %>%
mutate( psCum=BP+tot)
axisdf = don %>% group_by(CHR) %>% summarize(center=( max(psCum) + min(psCum) ) /2 )
#sig.level is set in the function line. is 0.05 default but not expecting hits above that.
bonferroni_sig <- sig.level/length(forplot$P)
# and plot. should just make the 1 plot.
# split don into shared SNPs and not shared SNPs, then merging together so the shared snps are at the bottom of the dataframe and will be plotted on top of the other points.
don_a <- don[don$shared == "#00FF00FF", ]
don_b <- don[don$shared != "#00FF00FF", ]
don_c <- rbind(don_b, don_a)
# start plot with don_b becuase that is most of what I'll need
m_plot <- ggplot(don_c, aes(x=psCum, y=-log10(P))) +
geom_point(aes(fill = fdr_col, color = shared), shape = 21, size = 1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "#FFC107", linetype = "dashed", alpha = 0.6)+
geom_segment(aes(x = 21551000, y = -0.3, xend = 30245000, yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x = (50122495+7329000), y = -0.3, xend = (50122495+ 8201000), yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x =(92167091+2408000 ), y = -0.3, xend = (92167091+2986000 ), yend = -0.3), col = "black", lineend = "round")+
scale_fill_manual(values = alpha(levels(don_c$fdr_col),0.8)) +
scale_color_manual(values = levels(don_c$shared))+
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= bquote(-log[10](p)))+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
## merge manhattan and qq into a single thing??
# this doesn't work as written because the ggplot is a grid object and the qqplot is not a grid object, so issues ensue.
#qqplot <- qqman::qq(forplot$P)
## would need the package that let's me make multi facet figures
## then set 2/3 or 3/4 spaces as mplot, and one as qq, then save the merged file
#final_fig <- ggarrange(m_plot, qqplot, nrow = 1, ncol = 2, widths = c(2,1))
##ggplot(forplot, aes(sample = P)+
##geom_qq()+
##geom_qq_line()+
##  labs(x = "Expected", y = "Observed")+
##  theme_bw()
ggsave(paste0(fig_name,".png"), plot = m_plot, width = 7, height = 3, dpi = 700, units = "in")
print(paste0("Done making plot for: ", identifier))
}
# going with this for now (11/3/2023) but I do think I could plot the shared ones as a second layer and then they would all be on the top rather than covered by some other points.
# there might also be a slighly overlap between color and fill that is creating a dark outline because both are at least somewhat transparent. Maybe I need to decrease size so it isn't 1.3?
##### Raw Phenotypes #####
manhattan_highlight(identifier = "NoCent.PlinkFiltering_raw.c", type = nocent)
##### Subset Raw Phenotypes #####
# only include if less than 2 as mean short stamen number
manhattan_highlight(identifier = "NoCent.PlinkFiltering_raw_subset.c", type = nocent)
##### Asin Phenotypes #####
manhattan_highlight(identifier = "NoCent.PlinkFiltering_Asin.c", type = nocent)
##### Binary Phenotypes #####
manhattan_highlight(identifier = "NoCent.PlinkFiltering_Binary.c", type = nocent)
##### Elevation! #####
manhattan_highlight(identifier = "NoCent.PlinkFiltering_Elev.c", type = nocent)
read.csv("data/AllChrs_Overlap_20240125.csv")
overlap_all <- read.csv("data/AllChrs_Overlap_20240125.csv")
# make list of just the locations
overlap_all <- list(overlap_all$rs)
View(overlap_all)
# read in all file
overlap_all <- read.csv("data/AllChrs_Overlap_20240125.csv")
# make list of just the locations
overlap_all <- c(overlap_all$rs)
remove_cent <- c("Chr1:14262517",
"Chr3:2239234",
"Chr3:2253161",
"Chr3:2942726",
"Chr5:4919727",
"Chr5:4920179",
"Chr5:4920289",
"Chr5:4920304",
"Chr5:4920731",
"Chr5:10731997",
"Chr5:13458838"
)
overlap_all[!(overlap_all %in% remove_cent)]
overlap_elev <- overlap_all[!(overlap_all %in% remove_cent)]
cent <- overlap_all[!(overlap_all %in% remove_cent)]
# run function - I manually renamed the one I made previously to conserve that
##### Elevation! #####
manhattan_highlight(identifier = "allSNPs.PlinkFiltering_Elev.c", type = cent)
# read in all file
overlap_nc <- read.csv("data/NoCent_Overlap_20240125.csv")
# make list of just the locations
overlap_nc <- c(overlap_nc$rs)
# remove the SNPs that are in the analysis because of only Short stamen number overlap
# no cent only shared SNPs
remove_nocent <- c("Chr3:2239234",
"Chr3:2253161",
"Chr3:2942726",
"Chr5:4919727",
"Chr5:4920179",
"Chr5:4920289",
"Chr5:4920304",
"Chr5:4920731",
"Chr5:10731997",
"Chr5:13458838"
)
nocent <- overlap_nc[!(overlap_nc %in% remove_nocent)]
manhattan_highlight(identifier = "NoCent.PlinkFiltering_Elev.c", type = nocent)
