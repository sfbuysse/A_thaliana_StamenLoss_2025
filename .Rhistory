tm_shape(pop_loc2)+
tm_text('pop', col = 'black', auto.placement = FALSE)+
tm_shape(pop_loc)+
tm_symbols('for.cols', palette=c(blue = 'blue', green = 'green', red = 'red', yellow = 'orange'),
stretch.palette = FALSE, size = 0.5, shape = 'for.shape',
shapes = c('0' = 22, '1' = 21, '2' = 24, '5' = 23),
legend.col.show = FALSE, legend.shape.show =  FALSE)
tm_shape(pyr_elev)+
tm_raster(palette = terrain.colors(10), alpha = 0.6, title = "Elevation")+
tm_scale_bar(position = c("right", "bottom"))+
tm_legend(legend.position = c("right", "bottom"))+
tm_shape(pop_loc2)+
tm_text('pop', col = 'black', auto.placement = FALSE)+
tm_shape(pop_loc)+
tm_symbols('for.cols', palette=c(blue = 'blue', green = 'green', red = 'red', yellow = 'orange'),
stretch.palette = FALSE, size = 0.5, shape = 'for.shape',
shapes = c('0' = 22, '1' = 21, '2' = 24, '5' = 23),
legend.col.show = FALSE, legend.shape.show =  FALSE)
## trying to find elevation of this population. based on this, it should be the 500 number and not the 200 number.
tmp_coc <- crop(elev_raster, as(extent(3.0, 3.5, 42.2, 42.4), 'SpatialPolygons'))
tm_shape(tmp_coc)+
tm_raster(palette = terrain.colors(10), alpha = 0.6, title = "Elevation")+
tm_legend(legend.position = c("right", "bottom"))+
tm_shape(pop_loc2)+
tm_text('pop', col = 'black', auto.placement = FALSE)+
tm_shape(pop_coc)+
tm_symbols()
tm_shape(tmp_coc)+
tm_raster(palette = terrain.colors(10), alpha = 0.6, title = "Elevation")+
tm_scale_bar(position = c("right", "bottom"))+
tm_legend(legend.position = c("right", "bottom"))+
tm_shape(pop_loc2)+
tm_text('pop', col = 'black', auto.placement = FALSE)+
tm_shape(pop_coc)+
tm_symbols()
#8/3/2023 update - working on different coloring scheme
# add columns for color and shape control
# manually checked with scheme from other figures. could have done this with more automation with rep() and ordering by elevation?
pop_loc$for.cols <- as.factor(c("red", "red", "red", "green", "yellow", "red", "green",
"blue", "yellow", "yellow", "blue", "green", "green", "blue", "blue", "yellow"))
pop_loc$elev <- as.factor(c(1229, 416, 441, 1444, 715, 519, 413, 836, 1585, 1706, 177, 665, 61, 332, 991, 1605))
pop_loc$for.shape <- as.factor(c(2,0,1,0,0,5,1,0,2,1,5,2,5,2,1,5))
# as.factor is important.
pop_loc$pop <- as.factor(pop_loc$pop)
# try to color like background
tm_shape(pyr_elev)+
tm_raster(palette = terrain.colors(16), alpha = 0.6, title = "Elevation")+
tm_scale_bar(position = c("right", "bottom"))+
tm_legend(legend.position = c("right", "bottom"))+
tm_shape(pop_loc2)+
tm_text('pop', col = 'black', auto.placement = FALSE)+
tm_shape(pop_loc)+
tm_symbols('elev', palette=terrain.colors(16),
stretch.palette = TRUE, size = 0.5, shape = 'for.shape',
shapes = c('0' = 22, '1' = 21, '2' = 24, '5' = 23),
legend.col.show = TRUE, legend.shape.show =  FALSE)
# just make a black point
black <-  tm_shape(pyr_elev)+
tm_raster(palette = terrain.colors(16), alpha = 0.8, title = "Elevation")+
tm_scale_bar(position = c("right", "bottom"))+
tm_legend(scale = 0.4, legend.outside = FALSE, legend.position = c("right", "bottom"))+
tm_shape(pop_loc2)+
tm_text('pop', col = 'black', auto.placement = FALSE, size = 1)+
tm_shape(pop_loc)+
tm_symbols(col = "black", border.col = "black", shape = 21,
stretch.palette = TRUE, size = 0.25,
legend.col.show = FALSE, legend.shape.show =  FALSE)
black
tmap_save(black, "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/BlackDotMap.png",
dpi = 1000,
outer.margins = c(0, 0, 0, 0),
insets_tm = outline,
insets_vp = viewport(x = unit(0.15, "npc"),
y = unit(0.18, "npc"),
width = unit(0.35, "npc"),
height = unit(0.35, "npc"),
default.units = "npc",
just = "centre",gp = gpar(),
clip = "inherit",
mask = "inherit",
xscale = c(0, 1),
yscale = c(0, 1),
angle = 0,
layout = NULL,
layout.pos.row = NULL, layout.pos.col = NULL,name = NULL),
width = 3 ,
height = 2,
units = 'in',
add.titles = "test")
load("04_Elev_Means_Feb2022.ROBJ")
one <- Elev_Means
load("Elev_Means_Feb2022")
load("Elev_Means_Feb2022.ROBJ")
rm(Elev_Means)
load("Elev_Means_Feb2022.ROBJ")
identical(Elev_means, one)
identical(Elev_Means, one)
knitr::opts_chunk$set(echo = TRUE)
## load data
Sequenced <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
PopMetaData <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv")
## load packages
library(emmeans)
library(lme4)
library(dplyr)
library(rcompanion) ## for plotNormalHistogram and blom functions (really don't need anymore if use hist() function)
library(rcompanion) ## for plotNormalHistogram and blom functions (really don't need anymore if use hist() function)
library(MASS) ## for boxcox transformation
library(bestNormalize)
## format columns as factors
Sequenced <- Sequenced[,1:9]
Sequenced$SeqSampleID <- as.factor(Sequenced$SeqSampleID)
Sequenced$Population <- as.factor(Sequenced$Population)
Sequenced$Line <- as.factor(Sequenced$Line)
Sequenced$Rep <- as.factor(toupper(Sequenced$Rep))
# Plant is equivalent to Rep
Sequenced$Tube <- as.factor(Sequenced$Tube)
str(Sequenced)
## calculate raw means
Seq_RawMeans <- Sequenced %>% group_by(SeqSampleID) %>%
summarize(Seq_LineFlwrMean = mean(Short_Stamens))
# only keep some of the metadata that will be important later on
PopMetaData <- PopMetaData[, c("PopCode", "Elev_m")]
# LSMs
## create a fully nested random model
colnames(Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ SeqSampleID + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
S_m3 <- lmer(Short_Stamens ~ Line:Population + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
anova(S_m2)
Seq_LSM <- summary(emmeans(S_m2, spec = "SeqSampleID"))
# compare values
Comp <- merge(Seq_RawMeans, Seq_LSM, by = "SeqSampleID")
View(Comp)
# let's see a correlations
cor.test(Comp$Seq_LineFlwrMean, Comp$emmean)
# to do transformations, I really only care about the distribution of the means, not which line they belong to
raw_means <- Seq_RawMeans$Seq_LineFlwrMean
plotNormalHistogram(raw_means)
shapiro.test(raw_means)
# best normalize package
# tests Yeo-Johnson, Box Cox, log10(x+a), sqrt(x+a), and arcsinh
# a = max(0, -min(x)+eps)
# can use new_transform argument to give best Normalise a list of functions to also use (I think this is basically what I am doing by hand below??)
bestNormalize(raw_means, standardize = FALSE, warm = TRUE)
# squared
means_squared <- raw_means^2
# square root
means_sqrt <- sqrt(raw_means)
# cubic root
means_cubrt <- (raw_means)^(1/3)
# log10
means_log10 <- log10(raw_means)
# natural log
means_log <- log(raw_means)
#inverse
means_inv <- (raw_means)^(-1)
# exponential
means_exp <- exp(raw_means)
# asin_proportion
# doesn't work on values greater than 1 b/c is for proportions
means_asin <- asin(raw_means/2)
# asin_prop_sqrt
# some sources (https://www.programmingr.com/tutorial/arcsine-transformation/) describe the arcsine transformation as needing to be arcsine of the square root
means_asin_sqrt <- asin(sqrt(raw_means/2))
# tukey
means_tukey <- transformTukey(raw_means)
box <- MASS::boxcox(raw_means ~ 1, lambda = seq(-5,5,0.1))
cox <- data.frame(box$x, box$y)
cox2 <- cox[with(cox, order(-cox$box.y)),]
cox2[1,]
lambda <- cox2[1, "box.x"]
means_bc_bn <- predict(bc)
# boxcox
bc <- bestNormalize::boxcox(raw_means)
means_bc_bn <- predict(bc)
means_bc_MASS <- ((raw_means^lambda)-1)/lambda
# rank (don't want to use this one b/c it basically forces a normal distribution)
# could be an comparison though? maybe not.
means_qqnorm <- qqnorm(raw_means, plot = F)
means_rank <- means_qqnorm[["x"]]
# blom - is a rank based method
means_blom <- blom(raw_means, method = "blom", alpha = 3/8, complete = T, na.last = NA)
###### make a list of my new phenotype lists #####
transformations <- list("raw" = raw_means, "squared" = means_squared, "sqrt" = means_sqrt, "Cube rt" = means_cubrt, "Log 10" = means_log10, "Natural Log" = means_log, "inverse" = means_inv, "exponential" = means_exp, "Asin of Proportion" = means_asin, "Asin of Sqrt(proportion)" = means_asin_sqrt, "Tukey" = means_tukey, "BoxCox (BestNormalize)" = means_bc_bn, "BoxCox (MASS)" = means_bc_MASS, "Rank" = means_rank, "Blom" = means_blom)
## make plots of everything
for (i in 1:length(transformations)){
plotNormalHistogram(transformations[[i]], main = names(transformations)[i])
}
## and do shapiro wilks tests
SW_test <- lapply(transformations, shapiro.test)
View(SW_test)
SW_test[["Asin of Sqrt(proportion)"]]
knitr::opts_chunk$set(echo = TRUE, tidy.opts = list(width.cutoff=75), tidy = TRUE)
## load packages
require(emmeans)
require(lme4)
require(dplyr)
#require(lsmeans)
## load data
Full <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_ByFlwr.csv")
Sequenced <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
PopMetaData <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv", header=TRUE)
## format columns as factors for both datasets
Full$Population <- as.factor(substr(x=Full$Population, 1, 3))
Full$Matriline <- as.factor(Full$Matriline)
Full$Plant <- as.factor(toupper(Full$Plant))
Full$PlantingBlock <- as.factor(Full$PlantingBlock)
Full$Tube <- as.factor(Full$Tube)
Full$Notes <- NULL
str(Full)
Sequenced <- Sequenced[,1:9]
Sequenced$Population <- as.factor(Sequenced$Population)
Sequenced$Line <- as.factor(Sequenced$Line)
Sequenced$Rep <- as.factor(toupper(Sequenced$Rep))
# Plant is equivalent to Rep
Sequenced$Tube <- as.factor(Sequenced$Tube)
str(Sequenced)
## create a fully nested random model
colnames(Full)
# full random model
F_m1 <- lmer(NumShortStamens ~ (1|Population) + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# mixed model
F_m2 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# full fixed model
F_m3 <- lm(NumShortStamens ~ Population + Matriline + Plant + Tube,
data = Full)
# add in planting block
F_m4 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population) + (1|PlantingBlock),
data = Full)
summary(F_m1)
summary(F_m2)
summary(F_m4)
anova(F_m1)
anova(F_m2)
anove(F_m4)
anova(F_m4)
Full_LSM <- summary(emmeans(F_m2, spec = "Population"))
View(Full_LSM)
# include block
Full2_LSM <- summary(emmeans(F_m4, spec = "Population"))
View(Full2_LSM)
# quick check correlation
cor(Full_LSM$emmean, Full2_LSM$emmean)
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean)
Full_RawMeans <- Full %>% group_by(Population) %>%
summarize(Full_PopFlwrMean = mean(NumShortStamens))
Seq_RawMeans <- Sequenced %>% group_by(Population) %>%
summarize(Seq_PopFlwrMean = mean(Short_Stamens))
# Create an output file (.ROBJ is good enough I think) with the Population, SSN, and elevation as metadata
Elev_Means <- merge(Full_RawMeans, Seq_RawMeans, by = "Population")
Elev_Means$Elev_m <- PopMetaData$Elev_m[match(Elev_Means$Population, PopMetaData$PopCode)]
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean)
View(Seq_LSM)
Seq_LSM <- summary(emmeans(S_m2, spec = "Population"))
View(S_m2)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
## create a fully nested random model
colnames(Sequenced)
# the important ones are Pop, Line, Rep, Tube to mimic what Jeff used
# Population
# line
# Rep
# Tube
# this doesn't include the flower b/c we want a mean
# full random model
S_m1 <- lmer(Short_Stamens ~ (1|Population) + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# full fixed model
S_m3 <- lm(Short_Stamens ~ Population + Line + Rep + Tube, data = Sequenced)
summary(S_m1)
summary(S_m2)
anova(S_m1)
anova(S_m2)
## create a fully nested random model
colnames(Sequenced)
# full random model
S_m1 <- lmer(Short_Stamens ~ (1|Population) + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# full fixed model
S_m3 <- lm(Short_Stamens ~ Population + Line + Rep + Tube, data = Sequenced)
summary(S_m1)
summary(S_m2)
anova(S_m1)
anova(S_m2)
Seq_LSM <- summary(emmeans(S_m2, spec = "Population"))
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean)
# let's see some correlations
cor.test(Comp$Full_PopFlwrMean, Comp$Full_LSM)
Comp <- merge(Elev_Means, LSMs, by = "Population")
# let's see some correlations
cor.test(Comp$Full_PopFlwrMean, Comp$Full_LSM)
cor.test(Comp$Full_PopFlwrMean, Comp$Full_Block)
cor.test(Comp$Full_LSM, Comp$Full_Block)
knitr::opts_chunk$set(echo = TRUE, tidy.opts = list(width.cutoff=75), tidy = TRUE)
## load packages
require(emmeans)
require(lme4)
require(dplyr)
#require(lsmeans)
## load data
Full <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_ByFlwr.csv")
## load packages
require(emmeans)
require(lme4)
require(dplyr)
#require(lsmeans)
## load data
Full <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_ByFlwr.csv")
Sequenced <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
PopMetaData <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv", header=TRUE)
## format columns as factors for both datasets
Full$Population <- as.factor(substr(x=Full$Population, 1, 3))
Full$Matriline <- as.factor(Full$Matriline)
Full$Plant <- as.factor(toupper(Full$Plant))
Full$PlantingBlock <- as.factor(Full$PlantingBlock)
Full$Tube <- as.factor(Full$Tube)
Full$Notes <- NULL
str(Full)
Sequenced <- Sequenced[,1:9]
Sequenced$Population <- as.factor(Sequenced$Population)
Sequenced$Line <- as.factor(Sequenced$Line)
Sequenced$Rep <- as.factor(toupper(Sequenced$Rep))
# Plant is equivalent to Rep
Sequenced$Tube <- as.factor(Sequenced$Tube)
str(Sequenced)
## create a fully nested random model
colnames(Full)
# the important ones are Pop, Line, Rep, Tube to mimic what Jeff used
# Population
# Matriline
# Plant
# Tube = timepoint so there are multiple flowers for each tube
# this doesn't include the flower b/c we want a mean
# doesn't use PlantingBlock Either.
# full random model
F_m1 <- lmer(NumShortStamens ~ (1|Population) + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# mixed model
F_m2 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# full fixed model
F_m3 <- lm(NumShortStamens ~ Population + Matriline + Plant + Tube,
data = Full)
# add in planting block
F_m4 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population) + (1|PlantingBlock),
data = Full)
summary(F_m1)
summary(F_m2)
summary(F_m4)
anova(F_m1)
anova(F_m2)
anova(F_m4)
## create a fully nested random model
colnames(Sequenced)
# the important ones are Pop, Line, Rep, Tube to mimic what Jeff used
# Population
# line
# Rep
# Tube
# this doesn't include the flower b/c we want a mean
# full random model
S_m1 <- lmer(Short_Stamens ~ (1|Population) + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# full fixed model
S_m3 <- lm(Short_Stamens ~ Population + Line + Rep + Tube, data = Sequenced)
summary(S_m1)
summary(S_m2)
anova(S_m1)
anova(S_m2)
Full_LSM <- summary(emmeans(F_m2, spec = "Population"))
# include block
Full2_LSM <- summary(emmeans(F_m4, spec = "Population"))
# quick check correlation
cor(Full_LSM$emmean, Full2_LSM$emmean)
# 0.9845071
# yayayayayaya!!
Seq_LSM <- summary(emmeans(S_m2, spec = "Population"))
Full_RawMeans <- Full %>% group_by(Population) %>%
summarize(Full_PopFlwrMean = mean(NumShortStamens))
Seq_RawMeans <- Sequenced %>% group_by(Population) %>%
summarize(Seq_PopFlwrMean = mean(Short_Stamens))
# Create an output file (.ROBJ is good enough I think) with the Population, SSN, and elevation as metadata
Elev_Means <- merge(Full_RawMeans, Seq_RawMeans, by = "Population")
Elev_Means$Elev_m <- PopMetaData$Elev_m[match(Elev_Means$Population, PopMetaData$PopCode)]
save(Elev_Means, file = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/Elev_Means_Feb2022.ROBJ")
View(Elev_Means)
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean)
Comp <- merge(Elev_Means, LSMs, by = "Population")
# let's see some correlations
cor.test(Comp$Full_PopFlwrMean, Comp$Full_LSM)
cor.test(Comp$Full_PopFlwrMean, Comp$Full_Block)
cor.test(Comp$Full_LSM, Comp$Full_Block)
cor.test(Comp$Full_PopFlwrMean, Comp$Seq_PopFlwrMean)
cor.test(Comp$Seq_PopFlwrMean, Comp$Seq_LSM)
# so all are highly correlated. Let's make a few plots just to visualize that
plot(Comp$Full_PopFlwrMean ~ Comp$Full_LSM)
lines(x = c(0,1,2), y = c(0,1,2))
plot(Comp$Full_PopFlwrMean ~ Comp$Seq_PopFlwrMean)
lines(x = c(0,1,2), y = c(0,1,2))
plot(Comp$Seq_PopFlwrMean ~ Comp$Seq_LSM)
lines(x = c(0,1,2), y = c(0,1,2))
cor.test(Comp$Full_PopFlwrMean, Comp$Full_Block)
View(Sequenced)
## load data
Full <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_ByFlwr.csv")
Sequenced <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
PopMetaData <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv", header=TRUE)
Full$Population <- as.factor(substr(x=Full$Population, 1, 3))
Full$Matriline <- as.factor(Full$Matriline)
Full$Plant <- as.factor(toupper(Full$Plant))
Full$PlantingBlock <- as.factor(Full$PlantingBlock)
Full$Tube <- as.factor(Full$Tube)
Full$Notes <- NULL
str(Full)
Sequenced <- Sequenced[,1:9]
Sequenced$Population <- as.factor(Sequenced$Population)
View(Sequenced)
Sequenced <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
View(Sequenced)
Sequenced$Population <- as.factor(Sequenced$Population)
Sequenced$Line <- as.factor(Sequenced$Line)
Sequenced$PlantingBlock <- as.factor(Sequenced$PlantingBlock)
Sequenced$Rep <- as.factor(toupper(Sequenced$Rep))
# Plant is equivalent to Rep
Sequenced$Tube <- as.factor(Sequenced$Tube)
str(Sequenced)
## create a fully nested random model
colnames(Full)
# the important ones are Pop, Line, Rep, Tube to mimic what Jeff used
# Population
# Matriline
# Plant
# Tube = timepoint so there are multiple flowers for each tube
# this doesn't include the flower b/c we want a mean
# doesn't use PlantingBlock Either.
# full random model
F_m1 <- lmer(NumShortStamens ~ (1|Population) + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# mixed model
F_m2 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# full fixed model
F_m3 <- lm(NumShortStamens ~ Population + Matriline + Plant + Tube,
data = Full)
# add in planting block
F_m4 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population) + (1|PlantingBlock),
data = Full)
summary(F_m1)
summary(F_m2)
summary(F_m4)
anova(F_m1)
anova(F_m2)
anova(F_m4)
## create a fully nested random model
colnames(Sequenced)
# full random model
S_m1 <- lmer(Short_Stamens ~ (1|Population) + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# full fixed model
S_m3 <- lm(Short_Stamens ~ Population + Line + Rep + Tube, data = Sequenced)
# add in planting block
S_m4 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population) + (1|PlantingBlock),
data = Sequenced)
summary(S_m2)
summary(S_m4)
anova(S_m2)
anova(S_m4)
Full_LSM <- summary(emmeans(F_m2, spec = "Population"))
# include block
Full2_LSM <- summary(emmeans(F_m4, spec = "Population"))
# quick check correlation
cor(Full_LSM$emmean, Full2_LSM$emmean)
# 0.9845071
# yayayayayaya!!
Seq_LSM <- summary(emmeans(S_m2, spec = "Population"))
# include block
Seq2_LSM <- summary(emmeans(S_m4, spec = "Population"))
# quick check correlation
cor(Seq_LSM$emmean, Seq2_LSM$emmean)
Full_RawMeans <- Full %>% group_by(Population) %>%
summarize(Full_PopFlwrMean = mean(NumShortStamens))
Seq_RawMeans <- Sequenced %>% group_by(Population) %>%
summarize(Seq_PopFlwrMean = mean(Short_Stamens))
# Create an output file (.ROBJ is good enough I think) with the Population, SSN, and elevation as metadata
Elev_Means <- merge(Full_RawMeans, Seq_RawMeans, by = "Population")
Elev_Means$Elev_m <- PopMetaData$Elev_m[match(Elev_Means$Population, PopMetaData$PopCode)]
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean, "Seq_Block" - Seq2_LSM$emmean)
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean, "Seq_Block" = Seq2_LSM$emmean)
Comp <- merge(Elev_Means, LSMs, by = "Population")
View(Comp)
cor.test(Comp$Seq_PopFlwrMean, Comp$Seq_Block)
plot(Comp$Seq_PopFlwrMean ~ Comp$Seq_Block)
lines(x = c(0,1,2), y = c(0,1,2))
