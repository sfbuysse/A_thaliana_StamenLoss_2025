summarize(Seq_LineFlwrMean = mean(Short_Stamens))
# only keep some of the metadata that will be important later on
PopMetaData <- PopMetaData[, c("PopCode", "Elev_m")]
# LSMs
## create a fully nested random model
colnames(Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ SeqSampleID + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
S_m3 <- lmer(Short_Stamens ~ Line:Population + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
anova(S_m2)
Seq_LSM <- summary(emmeans(S_m2, spec = "SeqSampleID"))
# compare values
Comp <- merge(Seq_RawMeans, Seq_LSM, by = "SeqSampleID")
View(Comp)
# let's see a correlations
cor.test(Comp$Seq_LineFlwrMean, Comp$emmean)
# to do transformations, I really only care about the distribution of the means, not which line they belong to
raw_means <- Seq_RawMeans$Seq_LineFlwrMean
plotNormalHistogram(raw_means)
shapiro.test(raw_means)
# best normalize package
# tests Yeo-Johnson, Box Cox, log10(x+a), sqrt(x+a), and arcsinh
# a = max(0, -min(x)+eps)
# can use new_transform argument to give best Normalise a list of functions to also use (I think this is basically what I am doing by hand below??)
bestNormalize(raw_means, standardize = FALSE, warm = TRUE)
# squared
means_squared <- raw_means^2
# square root
means_sqrt <- sqrt(raw_means)
# cubic root
means_cubrt <- (raw_means)^(1/3)
# log10
means_log10 <- log10(raw_means)
# natural log
means_log <- log(raw_means)
#inverse
means_inv <- (raw_means)^(-1)
# exponential
means_exp <- exp(raw_means)
# asin_proportion
# doesn't work on values greater than 1 b/c is for proportions
means_asin <- asin(raw_means/2)
# asin_prop_sqrt
# some sources (https://www.programmingr.com/tutorial/arcsine-transformation/) describe the arcsine transformation as needing to be arcsine of the square root
means_asin_sqrt <- asin(sqrt(raw_means/2))
# tukey
means_tukey <- transformTukey(raw_means)
box <- MASS::boxcox(raw_means ~ 1, lambda = seq(-5,5,0.1))
cox <- data.frame(box$x, box$y)
cox2 <- cox[with(cox, order(-cox$box.y)),]
cox2[1,]
lambda <- cox2[1, "box.x"]
means_bc_bn <- predict(bc)
# boxcox
bc <- bestNormalize::boxcox(raw_means)
means_bc_bn <- predict(bc)
means_bc_MASS <- ((raw_means^lambda)-1)/lambda
# rank (don't want to use this one b/c it basically forces a normal distribution)
# could be an comparison though? maybe not.
means_qqnorm <- qqnorm(raw_means, plot = F)
means_rank <- means_qqnorm[["x"]]
# blom - is a rank based method
means_blom <- blom(raw_means, method = "blom", alpha = 3/8, complete = T, na.last = NA)
###### make a list of my new phenotype lists #####
transformations <- list("raw" = raw_means, "squared" = means_squared, "sqrt" = means_sqrt, "Cube rt" = means_cubrt, "Log 10" = means_log10, "Natural Log" = means_log, "inverse" = means_inv, "exponential" = means_exp, "Asin of Proportion" = means_asin, "Asin of Sqrt(proportion)" = means_asin_sqrt, "Tukey" = means_tukey, "BoxCox (BestNormalize)" = means_bc_bn, "BoxCox (MASS)" = means_bc_MASS, "Rank" = means_rank, "Blom" = means_blom)
## make plots of everything
for (i in 1:length(transformations)){
plotNormalHistogram(transformations[[i]], main = names(transformations)[i])
}
## and do shapiro wilks tests
SW_test <- lapply(transformations, shapiro.test)
View(SW_test)
SW_test[["Asin of Sqrt(proportion)"]]
knitr::opts_chunk$set(echo = TRUE, tidy.opts = list(width.cutoff=75), tidy = TRUE)
## load packages
require(emmeans)
require(lme4)
require(dplyr)
#require(lsmeans)
## load data
Full <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_ByFlwr.csv")
Sequenced <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
PopMetaData <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv", header=TRUE)
## format columns as factors for both datasets
Full$Population <- as.factor(substr(x=Full$Population, 1, 3))
Full$Matriline <- as.factor(Full$Matriline)
Full$Plant <- as.factor(toupper(Full$Plant))
Full$PlantingBlock <- as.factor(Full$PlantingBlock)
Full$Tube <- as.factor(Full$Tube)
Full$Notes <- NULL
str(Full)
Sequenced <- Sequenced[,1:9]
Sequenced$Population <- as.factor(Sequenced$Population)
Sequenced$Line <- as.factor(Sequenced$Line)
Sequenced$Rep <- as.factor(toupper(Sequenced$Rep))
# Plant is equivalent to Rep
Sequenced$Tube <- as.factor(Sequenced$Tube)
str(Sequenced)
## create a fully nested random model
colnames(Full)
# full random model
F_m1 <- lmer(NumShortStamens ~ (1|Population) + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# mixed model
F_m2 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# full fixed model
F_m3 <- lm(NumShortStamens ~ Population + Matriline + Plant + Tube,
data = Full)
# add in planting block
F_m4 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population) + (1|PlantingBlock),
data = Full)
summary(F_m1)
summary(F_m2)
summary(F_m4)
anova(F_m1)
anova(F_m2)
anove(F_m4)
anova(F_m4)
Full_LSM <- summary(emmeans(F_m2, spec = "Population"))
View(Full_LSM)
# include block
Full2_LSM <- summary(emmeans(F_m4, spec = "Population"))
View(Full2_LSM)
# quick check correlation
cor(Full_LSM$emmean, Full2_LSM$emmean)
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean)
Full_RawMeans <- Full %>% group_by(Population) %>%
summarize(Full_PopFlwrMean = mean(NumShortStamens))
Seq_RawMeans <- Sequenced %>% group_by(Population) %>%
summarize(Seq_PopFlwrMean = mean(Short_Stamens))
# Create an output file (.ROBJ is good enough I think) with the Population, SSN, and elevation as metadata
Elev_Means <- merge(Full_RawMeans, Seq_RawMeans, by = "Population")
Elev_Means$Elev_m <- PopMetaData$Elev_m[match(Elev_Means$Population, PopMetaData$PopCode)]
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean)
View(Seq_LSM)
Seq_LSM <- summary(emmeans(S_m2, spec = "Population"))
View(S_m2)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
## create a fully nested random model
colnames(Sequenced)
# the important ones are Pop, Line, Rep, Tube to mimic what Jeff used
# Population
# line
# Rep
# Tube
# this doesn't include the flower b/c we want a mean
# full random model
S_m1 <- lmer(Short_Stamens ~ (1|Population) + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# full fixed model
S_m3 <- lm(Short_Stamens ~ Population + Line + Rep + Tube, data = Sequenced)
summary(S_m1)
summary(S_m2)
anova(S_m1)
anova(S_m2)
## create a fully nested random model
colnames(Sequenced)
# full random model
S_m1 <- lmer(Short_Stamens ~ (1|Population) + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# full fixed model
S_m3 <- lm(Short_Stamens ~ Population + Line + Rep + Tube, data = Sequenced)
summary(S_m1)
summary(S_m2)
anova(S_m1)
anova(S_m2)
Seq_LSM <- summary(emmeans(S_m2, spec = "Population"))
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean)
# let's see some correlations
cor.test(Comp$Full_PopFlwrMean, Comp$Full_LSM)
Comp <- merge(Elev_Means, LSMs, by = "Population")
# let's see some correlations
cor.test(Comp$Full_PopFlwrMean, Comp$Full_LSM)
cor.test(Comp$Full_PopFlwrMean, Comp$Full_Block)
cor.test(Comp$Full_LSM, Comp$Full_Block)
knitr::opts_chunk$set(echo = TRUE, tidy.opts = list(width.cutoff=75), tidy = TRUE)
## load packages
require(emmeans)
require(lme4)
require(dplyr)
#require(lsmeans)
## load data
Full <- read.csv("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_ByFlwr.csv")
## load packages
require(emmeans)
require(lme4)
require(dplyr)
#require(lsmeans)
## load data
Full <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_ByFlwr.csv")
Sequenced <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
PopMetaData <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv", header=TRUE)
## format columns as factors for both datasets
Full$Population <- as.factor(substr(x=Full$Population, 1, 3))
Full$Matriline <- as.factor(Full$Matriline)
Full$Plant <- as.factor(toupper(Full$Plant))
Full$PlantingBlock <- as.factor(Full$PlantingBlock)
Full$Tube <- as.factor(Full$Tube)
Full$Notes <- NULL
str(Full)
Sequenced <- Sequenced[,1:9]
Sequenced$Population <- as.factor(Sequenced$Population)
Sequenced$Line <- as.factor(Sequenced$Line)
Sequenced$Rep <- as.factor(toupper(Sequenced$Rep))
# Plant is equivalent to Rep
Sequenced$Tube <- as.factor(Sequenced$Tube)
str(Sequenced)
## create a fully nested random model
colnames(Full)
# the important ones are Pop, Line, Rep, Tube to mimic what Jeff used
# Population
# Matriline
# Plant
# Tube = timepoint so there are multiple flowers for each tube
# this doesn't include the flower b/c we want a mean
# doesn't use PlantingBlock Either.
# full random model
F_m1 <- lmer(NumShortStamens ~ (1|Population) + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# mixed model
F_m2 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# full fixed model
F_m3 <- lm(NumShortStamens ~ Population + Matriline + Plant + Tube,
data = Full)
# add in planting block
F_m4 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population) + (1|PlantingBlock),
data = Full)
summary(F_m1)
summary(F_m2)
summary(F_m4)
anova(F_m1)
anova(F_m2)
anova(F_m4)
## create a fully nested random model
colnames(Sequenced)
# the important ones are Pop, Line, Rep, Tube to mimic what Jeff used
# Population
# line
# Rep
# Tube
# this doesn't include the flower b/c we want a mean
# full random model
S_m1 <- lmer(Short_Stamens ~ (1|Population) + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# full fixed model
S_m3 <- lm(Short_Stamens ~ Population + Line + Rep + Tube, data = Sequenced)
summary(S_m1)
summary(S_m2)
anova(S_m1)
anova(S_m2)
Full_LSM <- summary(emmeans(F_m2, spec = "Population"))
# include block
Full2_LSM <- summary(emmeans(F_m4, spec = "Population"))
# quick check correlation
cor(Full_LSM$emmean, Full2_LSM$emmean)
# 0.9845071
# yayayayayaya!!
Seq_LSM <- summary(emmeans(S_m2, spec = "Population"))
Full_RawMeans <- Full %>% group_by(Population) %>%
summarize(Full_PopFlwrMean = mean(NumShortStamens))
Seq_RawMeans <- Sequenced %>% group_by(Population) %>%
summarize(Seq_PopFlwrMean = mean(Short_Stamens))
# Create an output file (.ROBJ is good enough I think) with the Population, SSN, and elevation as metadata
Elev_Means <- merge(Full_RawMeans, Seq_RawMeans, by = "Population")
Elev_Means$Elev_m <- PopMetaData$Elev_m[match(Elev_Means$Population, PopMetaData$PopCode)]
save(Elev_Means, file = "C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/Elev_Means_Feb2022.ROBJ")
View(Elev_Means)
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean)
Comp <- merge(Elev_Means, LSMs, by = "Population")
# let's see some correlations
cor.test(Comp$Full_PopFlwrMean, Comp$Full_LSM)
cor.test(Comp$Full_PopFlwrMean, Comp$Full_Block)
cor.test(Comp$Full_LSM, Comp$Full_Block)
cor.test(Comp$Full_PopFlwrMean, Comp$Seq_PopFlwrMean)
cor.test(Comp$Seq_PopFlwrMean, Comp$Seq_LSM)
# so all are highly correlated. Let's make a few plots just to visualize that
plot(Comp$Full_PopFlwrMean ~ Comp$Full_LSM)
lines(x = c(0,1,2), y = c(0,1,2))
plot(Comp$Full_PopFlwrMean ~ Comp$Seq_PopFlwrMean)
lines(x = c(0,1,2), y = c(0,1,2))
plot(Comp$Seq_PopFlwrMean ~ Comp$Seq_LSM)
lines(x = c(0,1,2), y = c(0,1,2))
cor.test(Comp$Full_PopFlwrMean, Comp$Full_Block)
View(Sequenced)
## load data
Full <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_ByFlwr.csv")
Sequenced <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
PopMetaData <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv", header=TRUE)
Full$Population <- as.factor(substr(x=Full$Population, 1, 3))
Full$Matriline <- as.factor(Full$Matriline)
Full$Plant <- as.factor(toupper(Full$Plant))
Full$PlantingBlock <- as.factor(Full$PlantingBlock)
Full$Tube <- as.factor(Full$Tube)
Full$Notes <- NULL
str(Full)
Sequenced <- Sequenced[,1:9]
Sequenced$Population <- as.factor(Sequenced$Population)
View(Sequenced)
Sequenced <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_Sequenced.csv")
View(Sequenced)
Sequenced$Population <- as.factor(Sequenced$Population)
Sequenced$Line <- as.factor(Sequenced$Line)
Sequenced$PlantingBlock <- as.factor(Sequenced$PlantingBlock)
Sequenced$Rep <- as.factor(toupper(Sequenced$Rep))
# Plant is equivalent to Rep
Sequenced$Tube <- as.factor(Sequenced$Tube)
str(Sequenced)
## create a fully nested random model
colnames(Full)
# the important ones are Pop, Line, Rep, Tube to mimic what Jeff used
# Population
# Matriline
# Plant
# Tube = timepoint so there are multiple flowers for each tube
# this doesn't include the flower b/c we want a mean
# doesn't use PlantingBlock Either.
# full random model
F_m1 <- lmer(NumShortStamens ~ (1|Population) + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# mixed model
F_m2 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population),
data = Full)
# full fixed model
F_m3 <- lm(NumShortStamens ~ Population + Matriline + Plant + Tube,
data = Full)
# add in planting block
F_m4 <- lmer(NumShortStamens ~ Population + (1|Matriline:Population) + (1|Plant:Matriline:Population) + (1|Tube:Plant:Matriline:Population) + (1|PlantingBlock),
data = Full)
summary(F_m1)
summary(F_m2)
summary(F_m4)
anova(F_m1)
anova(F_m2)
anova(F_m4)
## create a fully nested random model
colnames(Sequenced)
# full random model
S_m1 <- lmer(Short_Stamens ~ (1|Population) + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# mixed model
S_m2 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population),
data = Sequenced)
# full fixed model
S_m3 <- lm(Short_Stamens ~ Population + Line + Rep + Tube, data = Sequenced)
# add in planting block
S_m4 <- lmer(Short_Stamens ~ Population + (1|Line:Population) + (1|Rep:Line:Population) + (1|Tube:Rep:Line:Population) + (1|PlantingBlock),
data = Sequenced)
summary(S_m2)
summary(S_m4)
anova(S_m2)
anova(S_m4)
Full_LSM <- summary(emmeans(F_m2, spec = "Population"))
# include block
Full2_LSM <- summary(emmeans(F_m4, spec = "Population"))
# quick check correlation
cor(Full_LSM$emmean, Full2_LSM$emmean)
# 0.9845071
# yayayayayaya!!
Seq_LSM <- summary(emmeans(S_m2, spec = "Population"))
# include block
Seq2_LSM <- summary(emmeans(S_m4, spec = "Population"))
# quick check correlation
cor(Seq_LSM$emmean, Seq2_LSM$emmean)
Full_RawMeans <- Full %>% group_by(Population) %>%
summarize(Full_PopFlwrMean = mean(NumShortStamens))
Seq_RawMeans <- Sequenced %>% group_by(Population) %>%
summarize(Seq_PopFlwrMean = mean(Short_Stamens))
# Create an output file (.ROBJ is good enough I think) with the Population, SSN, and elevation as metadata
Elev_Means <- merge(Full_RawMeans, Seq_RawMeans, by = "Population")
Elev_Means$Elev_m <- PopMetaData$Elev_m[match(Elev_Means$Population, PopMetaData$PopCode)]
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean, "Seq_Block" - Seq2_LSM$emmean)
LSMs <- data.frame("Population" = Full_LSM$Population, "Full_LSM" = Full_LSM$emmean, "Full_Block" = Full2_LSM$emmean, "Pop2" = Seq_LSM$Population, "Seq_LSM" = Seq_LSM$emmean, "Seq_Block" = Seq2_LSM$emmean)
Comp <- merge(Elev_Means, LSMs, by = "Population")
View(Comp)
cor.test(Comp$Seq_PopFlwrMean, Comp$Seq_Block)
plot(Comp$Seq_PopFlwrMean ~ Comp$Seq_Block)
lines(x = c(0,1,2), y = c(0,1,2))
library(dplyr)
library(ggplot2)
eigenValues_test <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_plinkFilterTest.eigenval", sep = " ", header = F)
eigenVectors_test <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_plinkFilterTest.eigenvec", sep = " ", header = F)
# each row is a genotype, each column is a PC.
colnames(eigenVectors_test) <- c("Line", "SeqID", paste0("PC", 1:(ncol(eigenVectors_test)-2)))
library(dplyr)
library(ggplot2)
eigenValues_test <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_plinkFilterTest.eigenval", sep = " ", header = F)
eigenVectors_test <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_plinkFilterTest.eigenvec", sep = " ", header = F)
# each row is a genotype, each column is a PC.
colnames(eigenVectors_test) <- c("Line", "SeqID", paste0("PC", 1:(ncol(eigenVectors_test)-2)))
eigenValues_noBOS <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_noBOS.eigenval", sep = " ", header = F)
eigenVectors_noBOS <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_noBOS.eigenvec", sep = " ", header = F)
# each row is a genotype, each column is a PC.
colnames(eigenVectors_noBOS) <- c("Line", "SeqID", paste0("PC", 1:(ncol(eigenVectors_noBOS)-2)))
eigenValues_noCent <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_noCent.eigenval", sep = " ", header = F)
eigenVectors_noCent <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_noCent.eigenvec", sep = " ", header = F)
# each row is a genotype, each column is a PC.
colnames(eigenVectors_noCent) <- c("Line", "SeqID", paste0("PC", 1:(ncol(eigenVectors_noCent)-2)))
eigenValues_noCent_noBOS <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_nocent_noBOS.eigenval", sep = " ", header = F)
eigenVectors_noCent_noBOS <- read.delim("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/StamenLossPipeline/data/plinkPCA_nocent_noBOS.eigenvec", sep = " ", header = F)
# each row is a genotype, each column is a PC.
colnames(eigenVectors_noCent_noBOS) <- c("Line", "SeqID", paste0("PC", 1:(ncol(eigenVectors_noCent_noBOS)-2)))
pve_test <- round((eigenValues_test / (sum(eigenValues_test))*100), 2)
pve_test$PC <- c(1:20)
pve_pruned <- round((eigenValues_pruned / (sum(eigenValues_pruned))*100), 2)
pve_noBOS <- round((eigenValues_noBOS / (sum(eigenValues_noBOS))*100), 2)
pve_noBOS$PC <- c(1:20)
# definite drop after first four, 1 is 13, 2 is 10, 3 is 8.3, 4 is 7.` and the rest scale from 6 down to 2.25
pve_noCent <- round((eigenValues_noCent / (sum(eigenValues_noCent))*100), 2)
pve_noCent$PC <- c(1:20)
# matches the NO BOS results almost exactly? strange...
pve_noCent_noBOS <- round((eigenValues_noCent_noBOS / (sum(eigenValues_noCent_noBOS))*100), 2)
pve_noCent_noBOS$PC <- c(1:20)
# add pop column
eigenVectors_test$Pop <- toupper(substr(eigenVectors_test$Line, 1, 3))
eigenVectors_noBOS$Pop <- toupper(substr(eigenVectors_noBOS$Line, 1, 3))
eigenVectors_noCent$Pop <- toupper(substr(eigenVectors_noCent$Line, 1, 3))
eigenVectors_noCent_noBOS$Pop <- toupper(substr(eigenVectors_noCent_noBOS$Line, 1, 3))
# change ARB -> ARU and SPE -> SAL
eigenVectors_test[eigenVectors_test$Pop == "ARB", "Pop"] <- "ARU"
eigenVectors_test[eigenVectors_test$Pop == "SPE", "Pop"] <- "SAL"
eigenVectors_noBOS[eigenVectors_noBOS$Pop == "ARB", "Pop"] <- "ARU"
eigenVectors_noBOS[eigenVectors_noBOS$Pop == "SPE", "Pop"] <- "SAL"
eigenVectors_noCent[eigenVectors_noCent$Pop == "ARB", "Pop"] <- "ARU"
eigenVectors_noCent[eigenVectors_noCent$Pop == "SPE", "Pop"] <- "SAL"
eigenVectors_noCent_noBOS[eigenVectors_noCent_noBOS$Pop == "ARB", "Pop"] <- "ARU"
eigenVectors_noCent_noBOS[eigenVectors_noCent_noBOS$Pop == "SPE", "Pop"] <- "SAL"
# load the meta data
metadata <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/SpanishMasterDataset_PopMetaData.csv", header = TRUE)
# clean up a little
metadata <- metadata[1:16,c("Population", "PopCode", "Elev_m", "Lat_DecDeg", "Lon_DecDeg")]
# merge
eigenVectors_test$elev <- metadata$Elev_m[match(eigenVectors_test$Pop, metadata$PopCode)]
# then match with row names to add metadata column
# do this for lat and long now too
eigenVectors_test$lat <- metadata$Lat_DecDeg[match(eigenVectors_test$Pop, metadata$PopCode)]
eigenVectors_test$lon <- metadata$Lon_DecDeg[match(eigenVectors_test$Pop, metadata$PopCode)]
eigenVectors_noBOS$elev <- metadata$Elev_m[match(eigenVectors_noBOS$Pop, metadata$PopCode)]
# then match with row names to add metadata column
# do this for lat and long now too
eigenVectors_noBOS$lat <- metadata$Lat_DecDeg[match(eigenVectors_noBOS$Pop, metadata$PopCode)]
eigenVectors_noBOS$lon <- metadata$Lon_DecDeg[match(eigenVectors_noBOS$Pop, metadata$PopCode)]
eigenVectors_noCent$elev <- metadata$Elev_m[match(eigenVectors_noCent$Pop, metadata$PopCode)]
# then match with row names to add metadata column
# do this for lat and long now too
eigenVectors_noCent$lat <- metadata$Lat_DecDeg[match(eigenVectors_noCent$Pop, metadata$PopCode)]
eigenVectors_noCent$lon <- metadata$Lon_DecDeg[match(eigenVectors_noCent$Pop, metadata$PopCode)]
eigenVectors_noCent_noBOS$elev <- metadata$Elev_m[match(eigenVectors_noCent_noBOS$Pop, metadata$PopCode)]
# then match with row names to add metadata column
# do this for lat and long now too
eigenVectors_noCent_noBOS$lat <- metadata$Lat_DecDeg[match(eigenVectors_noCent_noBOS$Pop, metadata$PopCode)]
eigenVectors_noCent_noBOS$lon <- metadata$Lon_DecDeg[match(eigenVectors_noCent_noBOS$Pop, metadata$PopCode)]
# order by elevation and make labels column
eigenVectors_test <- eigenVectors_test[order(eigenVectors_test$elev),]
eigenVectors_test$label <- paste0(eigenVectors_test$Pop, " - ", eigenVectors_test$elev, "m")
#eigenVectors_test$Pop <- as.factor(eigenVectors_test$Pop)
eigenVectors_test$Pop <- factor(eigenVectors_test$Pop, levels = unique(eigenVectors_test$Pop[order(eigenVectors_test$elev)]))
str(eigenVectors_test)
eigenVectors_noBOS <- eigenVectors_noBOS[order(eigenVectors_noBOS$elev),]
eigenVectors_noBOS$label <- paste0(eigenVectors_noBOS$Pop, " - ", eigenVectors_noBOS$elev, "m")
eigenVectors_noBOS$Pop <- factor(eigenVectors_noBOS$Pop, levels = unique(eigenVectors_noBOS$Pop[order(eigenVectors_noBOS$elev)]))
eigenVectors_noCent <- eigenVectors_noCent[order(eigenVectors_noCent$elev),]
eigenVectors_noCent$label <- paste0(eigenVectors_noCent$Pop, " - ", eigenVectors_noCent$elev, "m")
eigenVectors_noCent$Pop <- factor(eigenVectors_noCent$Pop, levels = unique(eigenVectors_noCent$Pop[order(eigenVectors_noCent$elev)]))
eigenVectors_noCent_noBOS <- eigenVectors_noCent_noBOS[order(eigenVectors_noCent_noBOS$elev),]
eigenVectors_noCent_noBOS$label <- paste0(eigenVectors_noCent_noBOS$Pop, " - ", eigenVectors_noCent_noBOS$elev, "m")
eigenVectors_noCent_noBOS$Pop <- factor(eigenVectors_noCent_noBOS$Pop, levels = unique(eigenVectors_noCent_noBOS$Pop[order(eigenVectors_noCent_noBOS$elev)]))
# let's make a subset dataframe of the variables we are interested in
cor_test <- eigenVectors_test[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon")]
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
round(cor(cor_test), 2)
cot.test
cor.test
cor_test
head(eigenVectors_test)
# let's make a subset dataframe of the variables we are interested in
cor_test <- eigenVectors_test[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
# let's make a subset dataframe of the variables we are interested in
cor_test <- eigenVectors_test[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
cor_noBOS <- eigenVectors_noBOS[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
cor_noCent <- eigenVectors_noCent[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
cor_noCent_noBOS <- eigenVectors_noCent_noBOS[,c("PC1", "PC2", "PC3", "PC4", "elev", "lat", "lon", "Pop")]
summary_test <- cor_test %>%
group_by(Pop) %>%
summarize("elev" = mean(elev), "lat" = mean(lat), "lon" = mean(lon), "PC1" = mean(PC1), "PC2" = mean(PC2), "PC3" = mean(PC3), "PC4" = mean(PC4))
View(summary_test)
round(cor(summary_test), 2)
round(cor(summary_test[ ,2:7]), 2)
round(cor(summary_test[ ,2:8]), 2)
cor.test(summary_test$elev, summary_test$PC1)
# p = 0.0009217, cor = -0.745
cor.test(summary_test$elev, summary_test$PC2)
round(cor(summary_test[ ,2:8]), 2)
# p = 0.03083, cor = -0.5400
cor.test(summary_test$elev, summary_test$PC3)
cor.test(summary_test$elev, summary_test$PC4)
cor.test(summary_test$elev, summary_test$PC3)
cor.test(summary_test$elev, summary_test$PC4)
