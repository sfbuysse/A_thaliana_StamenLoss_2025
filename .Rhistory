is.na(chr1_overlap_nc[[1]][,c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")])
structure(list(V2QE38A = c(1, 0, 1, 0, 1, 1, 1, 0, 1, 0), V2QE38B = c(0,
0, 0, 0, 0, 1, 0, 0, 0, 0), V2QE38C = c(1, 1, 0, 3, 2, 0, 0,
3, 1, 1), V2QE38D = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)), row.names = c(NA,
10L), class = "data.frame")
df <- structure(list(V2QE38A = c(1, 0, 1, 0, 1, 1, 1, 0, 1, 0), V2QE38B = c(0,
0, 0, 0, 0, 1, 0, 0, 0, 0), V2QE38C = c(1, 1, 0, 3, 2, 0, 0,
3, 1, 1), V2QE38D = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)), row.names = c(NA,
10L), class = "data.frame")
df <- structure(list(V2QE38A = c(1, 0, 1, 0, 1, 1, 1, 0, 1, 0),
V2QE38B = c(0,  0, 0, 0, 0, 1, 0, 0, 0, 0),
V2QE38C = c(1, 1, 0, 3, 2, 0, 0, 3, 1, 1),
V2QE38D = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)),
row.names = c(NA, 10L), class = "data.frame")
df
colSums(is.na(chr1_overlap_nc[[1]][,c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")]))
colSums(is.na(chr1_overlap_nc[[1]][,c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")])) < length(chr1_overlap_nc[[1]]$ps)
sum(colSums(is.na(chr1_overlap_nc[[1]][,c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")])) < length(chr1_overlap_nc[[1]]$ps))
length(chr1_overlap_nc)
# problem with this is that the code checks by row, so this would require a single SNP to show up in multiple which is not what I want
# so I don't think I can use rowSums because I don't want the row aspect of requiring it to be a single SNP.
# I can use colSums. and then I want to keep any data frame where 2 of the columns have colSums less than the number of rows in that dataframe.
# okay so I got it so I get the sum of columns that are not fully NAs. Then I only want to keep the whole dataframe if that sum is greater than 1. how do I do that part? so maybe I should first just make a list of the sums for each dataframe in my list of dataframes.
Cols_with_values <- list()
for(d in c(1:length(chr1_overlap_nc))){
Cols_with_values[[d]] <- sum(colSums(is.na(chr1_overlap_nc[[e]][,c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")])) < length(chr1_overlap_nc[[e]]$ps))
}
for(d in c(1:length(chr1_overlap_nc))){
Cols_with_values[[d]] <- sum(colSums(is.na(chr1_overlap_nc[[e]][,c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")])) < length(chr1_overlap_nc[[d]]$ps))
}
for(d in c(1:length(chr1_overlap_nc))){
Cols_with_values[[d]] <- sum(colSums(is.na(chr1_overlap_nc[[d]][,c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")])) < length(chr1_overlap_nc[[d]]$ps))
}
View(Cols_with_values)
df1 <- data.frame("p_binary_nc" = c(NA, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(0.1, NA, NA, NA))
# df with 1 value per row, but each value is in a different column
df2 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(NA, 0.1, NA, NA), "p_asin_nc"= c(NA, NA, 0.1, NA), "p_subset_nc"= c(NA, NA, NA, 0.1))
# df that is all NAs
df3 <- data.frame("p_binary_nc" = c(NA, NA, NA, NA), "p_raw_nc" = c(NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA))
# df with values in the same row of multiple columns
df4 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(0.1, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA))
# df with values in the same row of multiple columns. and values in two rows
df5 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(0.1, NA, NA, NA), "p_asin_nc"= c(NA, NA, 0.1, NA), "p_subset_nc"= c(NA, NA, NA, 0.1))
# all values everywhere, and a different length
df6 <- data.frame("p_binary_nc" = c(0.1, 0.1, 0.1), "p_raw_nc" = c(0.1, 0.1, 0.1), "p_asin_nc"= c(0.1, 0.1, 0.1), "p_subset_nc"= c(0.1, 0.1, 0.1))
# df1 but different length
df1 <- data.frame("p_binary_nc" = c(NA, 0.1, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA, NA), "p_subset_nc"= c(0.1, NA, NA, NA, NA))
tmp_dfs <- list(df1, df2, df3, df4, df5, df6, df7)
df1 <- data.frame("p_binary_nc" = c(NA, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(0.1, NA, NA, NA))
# df with 1 value per row, but each value is in a different column
df2 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(NA, 0.1, NA, NA), "p_asin_nc"= c(NA, NA, 0.1, NA), "p_subset_nc"= c(NA, NA, NA, 0.1))
# df that is all NAs
df3 <- data.frame("p_binary_nc" = c(NA, NA, NA, NA), "p_raw_nc" = c(NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA))
# df with values in the same row of multiple columns
df4 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(0.1, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA))
# df with values in the same row of multiple columns. and values in two rows
df5 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(0.1, NA, NA, NA), "p_asin_nc"= c(NA, NA, 0.1, NA), "p_subset_nc"= c(NA, NA, NA, 0.1))
# all values everywhere, and a different length
df6 <- data.frame("p_binary_nc" = c(0.1, 0.1, 0.1), "p_raw_nc" = c(0.1, 0.1, 0.1), "p_asin_nc"= c(0.1, 0.1, 0.1), "p_subset_nc"= c(0.1, 0.1, 0.1))
# df1 but different length
df7 <- data.frame("p_binary_nc" = c(NA, 0.1, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA, NA), "p_subset_nc"= c(0.1, NA, NA, NA, NA))
tmp_dfs <- list(df1, df2, df3, df4, df5, df6, df7)
# data frame with only 1 value per row, but values are in 2 different columns
df1 <- data.frame("p_binary_nc" = c(NA, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(0.1, NA, NA, NA))
# df with 1 value per row, but each value is in a different column
df2 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(NA, 0.1, NA, NA), "p_asin_nc"= c(NA, NA, 0.1, NA), "p_subset_nc"= c(NA, NA, NA, 0.1))
# df that is all NAs
df3 <- data.frame("p_binary_nc" = c(NA, NA, NA, NA), "p_raw_nc" = c(NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA))
# df with values in the same row of multiple columns
df4 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(0.1, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA))
# df with values in the same row of multiple columns. and values in two rows
df5 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(0.1, NA, NA, NA), "p_asin_nc"= c(NA, NA, 0.1, NA), "p_subset_nc"= c(NA, NA, NA, 0.1))
# all values everywhere, and a different length
df6 <- data.frame("p_binary_nc" = c(0.1, 0.1, 0.1), "p_raw_nc" = c(0.1, 0.1, 0.1), "p_asin_nc"= c(0.1, 0.1, 0.1), "p_subset_nc"= c(0.1, 0.1, 0.1))
# df1 but different length
df7 <- data.frame("p_binary_nc" = c(NA, 0.1, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA, NA), "p_subset_nc"= c(0.1, NA, NA, NA, NA))
# all values in one column
df8 <- df7 <- data.frame("p_binary_nc" = c(0.1, 0.1, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA, NA))
tmp_dfs <- list(df1, df2, df3, df4, df5, df6, df7, df8)
# loop!
Cols_with_values <- list()
# data frame with only 1 value per row, but values are in 2 different columns
df1 <- data.frame("p_binary_nc" = c(NA, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(0.1, NA, NA, NA))
# df with 1 value per row, but each value is in a different column
df2 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(NA, 0.1, NA, NA), "p_asin_nc"= c(NA, NA, 0.1, NA), "p_subset_nc"= c(NA, NA, NA, 0.1))
# df that is all NAs
df3 <- data.frame("p_binary_nc" = c(NA, NA, NA, NA), "p_raw_nc" = c(NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA))
# df with values in the same row of multiple columns
df4 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(0.1, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA))
# df with values in the same row of multiple columns. and values in two rows
df5 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(0.1, NA, NA, NA), "p_asin_nc"= c(NA, NA, 0.1, NA), "p_subset_nc"= c(NA, NA, NA, 0.1))
# all values everywhere, and a different length
df6 <- data.frame("p_binary_nc" = c(0.1, 0.1, 0.1), "p_raw_nc" = c(0.1, 0.1, 0.1), "p_asin_nc"= c(0.1, 0.1, 0.1), "p_subset_nc"= c(0.1, 0.1, 0.1))
# df1 but different length
df7 <- data.frame("p_binary_nc" = c(NA, 0.1, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA, NA), "p_subset_nc"= c(0.1, NA, NA, NA, NA))
# all values in one column
df8 <- df7 <- data.frame("p_binary_nc" = c(0.1, 0.1, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA, NA))
tmp_dfs <- list(df1, df2, df3, df4, df5, df6, df7, df8)
# I want my code to keep any instance where there are values in multiple columns, so that would be all but df3 and df8
# loop!
Cols_with_values <- list()
for(d in c(1:length(tmp_dfs))){
Cols_with_values[[d]] <- sum(colSums(is.na(tmp_dfs[[d]][,c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")])) < length(tmp_dfs[[d]]$p_raw_nc))
}
View(Cols_with_values)
### test to make sure it works on different types of dataframes. ###
# data frame with only 1 value per row, but values are in 2 different columns
df1 <- data.frame("p_binary_nc" = c(NA, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(0.1, NA, NA, NA))
# df with 1 value per row, but each value is in a different column
df2 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(NA, 0.1, NA, NA), "p_asin_nc"= c(NA, NA, 0.1, NA), "p_subset_nc"= c(NA, NA, NA, 0.1))
# df that is all NAs
df3 <- data.frame("p_binary_nc" = c(NA, NA, NA, NA), "p_raw_nc" = c(NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA))
# df with values in the same row of multiple columns
df4 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(0.1, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA))
# df with values in the same row of multiple columns. and values in two rows
df5 <- data.frame("p_binary_nc" = c(0.1, NA, NA, NA), "p_raw_nc" = c(0.1, NA, NA, NA), "p_asin_nc"= c(NA, NA, 0.1, NA), "p_subset_nc"= c(NA, NA, NA, 0.1))
# all values everywhere, and a different length
df6 <- data.frame("p_binary_nc" = c(0.1, 0.1, 0.1), "p_raw_nc" = c(0.1, 0.1, 0.1), "p_asin_nc"= c(0.1, 0.1, 0.1), "p_subset_nc"= c(0.1, 0.1, 0.1))
# df1 but different length
df7 <- data.frame("p_binary_nc" = c(NA, 0.1, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA, NA), "p_subset_nc"= c(0.1, NA, NA, NA, NA))
# all values in one column
df8 <- data.frame("p_binary_nc" = c(0.1, 0.1, 0.1, 0.1, 0.1), "p_raw_nc" = c(NA, NA, NA, NA, NA), "p_asin_nc"= c(NA, NA, NA, NA, NA), "p_subset_nc"= c(NA, NA, NA, NA, NA))
tmp_dfs <- list(df1, df2, df3, df4, df5, df6, df7, df8)
# I want my code to keep any instance where there are values in multiple columns, so that would be all but df3 and df8
# loop!
Cols_with_values <- list()
for(d in c(1:length(tmp_dfs))){
Cols_with_values[[d]] <- sum(colSums(is.na(tmp_dfs[[d]][,c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")])) < length(tmp_dfs[[d]]$p_raw_nc))
}
# loop!
Cols_with_values <- c()
for(d in c(1:length(tmp_dfs))){
Cols_with_values[[d]] <- sum(colSums(is.na(tmp_dfs[[d]][,c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")])) < length(tmp_dfs[[d]]$p_raw_nc))
}
# loop!
Cols_with_values <- c()
for(d in c(1:length(tmp_dfs))){
Cols_with_values[d] <- sum(colSums(is.na(tmp_dfs[[d]][,c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")])) < length(tmp_dfs[[d]]$p_raw_nc))
}
# I then want to subset tmp_dfs based on this and only keep the entries where the corresponding Cols_with_values entry is greater than 1
tmp_dfs_2 <- tmp_dfs[Cols_with_values]
View(tmp_dfs_2)
View(tmp_dfs)
c(Cols_with_values > 1)
# I then want to subset tmp_dfs based on this and only keep the entries where the corresponding Cols_with_values entry is greater than 1
tmp_dfs_2 <- tmp_dfs[c(Cols_with_values > 1)]
# I then want to subset tmp_dfs based on this and only keep the entries where the corresponding Cols_with_values entry is greater than 1
tmp_dfs_2 <- tmp_dfs[[c(Cols_with_values > 1)]]
# I then want to subset tmp_dfs based on this and only keep the entries where the corresponding Cols_with_values entry is greater than 1
tmp_dfs_2 <- tmp_dfs[c(Cols_with_values > 1)]
top_hits_fdr_all <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/Top_hits_fdr_wald_Apr2023.csv")
# take out elevation for now and see if that increases the workability of my loop output
# problem with this code is that it gets rid of any row that has a value for elev even if it overlaps with a different one, so maybe just get rid of that column? but I really need to reduce rows to get an easier to read output... hm how to do this
# maybe I need to do it in two steps. first step would be to get rid of the columns, second step would be to get rid of rows that are all NAs
th_fdr_noelev <- top_hits_fdr_all[, grep("elev", colnames(top_hits_fdr_all), value = TRUE, invert = TRUE)]
# maybe to solve the problem of making sure the overlap is between two GWAS types, I should also only look at either all or NoCent at once
# using the 'inverse of all' code so the first three columns are also kept
th_noelev_nocent <- top_hits_fdr_all[, grep("all", colnames(th_fdr_noelev), value = TRUE, invert = TRUE)]
# using the 'inverse of nocent' code so the first three columns are also kept
th_noelev_all <- top_hits_fdr_all[, grep("nc", colnames(th_fdr_noelev), value = TRUE, invert = TRUE)]
# so count NAs, and  keep rows with fewer than 12 NAs (3 columns should have values for all rows)
th_noelev_nocent <- th_noelev_nocent[rowSums(is.na(th_noelev_nocent)) < 12 , ]
# sample size went way down!
th_noelev_all <- th_noelev_all[rowSums(is.na(th_noelev_all)) < 12 , ]
# sample size went way down! but is larger than no cent.
#### chr 1 ####
##### no cent #####
# only keep the p value columns
hits_fdr_chr1 <- th_noelev_nocent[(th_noelev_nocent$chr == 1), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE))]
#make a 1000bp window centered on the SNP
hits_fdr_chr1$min <- hits_fdr_chr1$ps - 500
hits_fdr_chr1$max <- hits_fdr_chr1$ps + 500
# place for output
chr1_overlap_nc <- list()
# nested loops
for (i in c(1:length(hits_fdr_chr1$ps))){
tmp_list <- c(hits_fdr_chr1$min[i]:hits_fdr_chr1$max[i])
tmp_df <- data.frame()
for (j in c(1:length(hits_fdr_chr1$ps))){
if (hits_fdr_chr1$ps[j] %in% tmp_list) {
tmp_df <- rbind(tmp_df, hits_fdr_chr1[j, ])}
}
if (length(tmp_df[,1]) > 1) {
chr1_overlap_nc <- append(chr1_overlap_nc, list(tmp_df))}
#print("End")
}
length(unique(chr1_overlap_nc)) # only 115 are unique, that seems promising;
# problem with this is that the code checks by row, so this would require a single SNP to show up in multiple which is not what I want
# so I don't think I can use rowSums because I don't want the row aspect of requiring it to be a single SNP.
# I can use colSums. and then I want to keep any data frame where 2 of the columns have colSums less than the number of rows in that dataframe.
# okay so I got it so I get the sum of columns that are not fully NAs. Then I only want to keep the whole dataframe if that sum is greater than 1. how do I do that part? so maybe I should first just make a list of the sums for each dataframe in my list of dataframes.
cols_with_values <- c()
for(d in c(1:length(chr1_overlap_nc))){
cols_with_values[d] <- sum(colSums(is.na(chr1_overlap_nc[[d]][,c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")])) < length(chr1_overlap_nc[[d]]$ps))
}
sum(cols_with_values)
# don't expect this to keep any
chr1_overlap_nc2 <- chr1_overlap_nc[c(cols_with_values > 1)]
cols_with_values <- c()
hits_fdr_chr1_a$min <- hits_fdr_chr1_a$ps - 500
#maybe try it on all instead of NC?
##### all  #####
# only keep the p value columns
hits_fdr_chr1_a <- th_noelev_all[(th_noelev_all$chr == 1), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_all), value = TRUE))]
#make a 1000bp window centered on the SNP
hits_fdr_chr1_a$min <- hits_fdr_chr1_a$ps - 500
hits_fdr_chr1_a$max <- hits_fdr_chr1_a$ps + 500
# place for output
chr1_overlap_all <- list()
# nested loops
for (i in c(1:length(hits_fdr_chr1_a$ps))){
tmp_list <- c(hits_fdr_chr1_a$min[i]:hits_fdr_chr1_a$max[i])
tmp_df <- data.frame()
for (j in c(1:length(hits_fdr_chr1_a$ps))){
if (hits_fdr_chr1_a$ps[j] %in% tmp_list) {
tmp_df <- rbind(tmp_df, hits_fdr_chr1_a[j, ])}
}
if (length(tmp_df[,1]) > 1) {
chr1_overlap_all <- append(chr1_overlap_all, list(tmp_df))}
#print("End")
}
# This has 279 entries
length(unique(chr1_overlap_all)) # only 133 are unique
cols_with_values <- c()
for(d in c(1:length(chr1_overlap_all))){
cols_with_values[d] <- sum(colSums(is.na(chr1_overlap_all[[d]][,c("p_binary_all", "p_raw_all", "p_asin_all", "p_subset_all")])) < length(chr1_overlap_all[[d]]$ps))
}
sum(cols_with_values)
# don't expect this to keep any
chr1_overlap_all2 <- chr1_overlap_all[c(cols_with_values > 1)]
knitr::opts_chunk$set(echo = TRUE)
# read in packages
library(ggplot2)
library(dplyr)
library(qqman)
# list of all the files I am interested in
files <- c("NoCent.PlinkFiltering_Binary.c", "NoCent.PlinkFiltering_raw.c",  "NoCent.PlinkFiltering_Asin.c", "NoCent.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Asin.c", "allSNPs.PlinkFiltering_raw.c", "allSNPs.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Binary.c", "allSNPs.PlinkFiltering_raw_subset.c", "NoCent.PlinkFiltering_raw_subset.c")
# could then theoretically lapply my function to this list of names
# does not include the testing file b/c not needed here.
# read in packages
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(qqman))
# list of all the files I am interested in
files <- c("NoCent.PlinkFiltering_Binary.c", "NoCent.PlinkFiltering_raw.c",  "NoCent.PlinkFiltering_Asin.c", "NoCent.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Asin.c", "allSNPs.PlinkFiltering_raw.c", "allSNPs.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Binary.c", "allSNPs.PlinkFiltering_raw_subset.c", "NoCent.PlinkFiltering_raw_subset.c")
# could then theoretically lapply my function to this list of names
# does not include the testing file b/c not needed here.
# load in the file!
load(file = "C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/R_script/GWAS_fdradjusted_pvals.ROBJ")
# the indexing should be the same, so I should be able to use the indexing from fdr_pvals
#so for each gwas file, I want to subset out based on fdr_vals[[i]] < 0.10
# let's test it on no cent binary
nocent_bin <- read.delim(file = paste0("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/", files[1], ".assoc.txt"))
# the indexing should be the same, so I should be able to use the indexing from fdr_pvals
#so for each gwas file, I want to subset out based on fdr_vals[[i]] < 0.10
# let's test it on no cent binary
nocent_bin <- read.delim(file = paste0("C:/Users/Sophia/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/", files[1], ".assoc.txt"))
# check that lengths match
length(nocent_bin$ps)
length(fdr_pvals[[1]])
# pull them out
nocent_bin_top <- nocent_bin[fdr_pvals[[1]] < 0.10, ]
# check expected output lengths match
sum(fdr_pvals[[1]] < 0.10)
length(nocent_bin_top$ps)
rm(fdr_pvals)
rm(nocent_bin)
knitr::opts_chunk$set(echo = TRUE)
library(praise)
##### do it time 3 #####
# read in top hits file
top_hits_fdr_all <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/Top_hits_fdr_wald_Apr2023.csv")
#make a 1000bp window centered on the SNP
top_hits_fdr_all$min <- top_hits_fdr_all$ps - 500
top_hits_fdr_all$max <- top_hits_fdr_all$ps + 500
# problem with this code is that it gets rid of any row that has a value for elev even if it overlaps with a different one, so maybe just get rid of that column? but I really need to reduce rows to get an easier to read output... hm how to do this
# maybe I need to do it in two steps. first step would be to get rid of the columns, second step would be to get rid of rows that are all NAs
th_fdr_noelev <- top_hits_fdr_all[, grep("elev", colnames(top_hits_fdr_all), value = TRUE, invert = TRUE)]
# maybe to solve the problem of making sure the overlap is between two GWAS types, I should also only look at either all or NoCent at once
# using the 'inverse of all' code so the first three columns are also kept
th_noelev_nocent <- top_hits_fdr_all[, grep("all", colnames(th_fdr_noelev), value = TRUE, invert = TRUE)]
# using the 'inverse of nocent' code so the first three columns are also kept
th_noelev_all <- top_hits_fdr_all[, grep("nc", colnames(th_fdr_noelev), value = TRUE, invert = TRUE)]
# so count NAs, and  keep rows with fewer than 12 NAs (3 columns should have values for all rows)
th_noelev_nocent <- th_noelev_nocent[rowSums(is.na(th_noelev_nocent)) < 12 , ]
# sample size went way down!
th_noelev_all <- th_noelev_all[rowSums(is.na(th_noelev_all)) < 12 , ]
# nested loops that give me an output that is a list of dataframes with at least 2 overlapping SNPs in the window
id_snps <- function(input){
output <- list()
len <- length(input$ps) # to this point works
for (i in c(1:len)){
tmp_list <- c(input$min[i]:input$max[i])
tmp_df <- data.frame()
for (j in c(1:len)){
if (input$ps[j] %in% tmp_list) {
tmp_df <- rbind(tmp_df, input[j, ])}
}
if (length(tmp_df[,1]) > 1){
output <- append(output, list(tmp_df))}
}
return(output)
}
# function to identify if any of the overlapping regions are between at least 2 GWAS types
# issue with this function is that the columns to check will change depending on if it is an nc file or an all file
# I think this function might actually need a bit more testing
nc_p_cols <- c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")
all_p_cols <- c("p_binary_all", "p_raw_all", "p_asin_all", "p_subset_all")
gwas_overlap <- function(input, keep_cols){
cols_with_values <- c()
for(d in c(1:length(input))){
cols_with_values[d] <- sum(colSums(is.na(input[[d]][,keep_cols])) < length(input[[d]][ ,1]))
}
# then write out the dataframes from the initial list
output <- input[c(cols_with_values > 1)]
return(output)
}
#### chr 1 ####
##### no cent #####
# only keep the p value columns
hits_fdr_chr1 <- th_noelev_nocent[(th_noelev_nocent$chr == 1), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr1_overlap_nc <- id_snps(hits_fdr_chr1)
length(unique(chr1_overlap_nc)) # only 115 are unique, that seems promising;
# don't expect this to keep any
OverlapHits_chr1_nc <- gwas_overlap(chr1_overlap_nc, nc_p_cols)
#maybe try it on all instead of NC?
##### all  #####
# only keep the p value columns
hits_fdr_chr1_a <- th_noelev_all[(th_noelev_all$chr == 1), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr1_overlap_all <- id_snps(hits_fdr_chr1_a)
# This has 279 entries
length(unique(chr1_overlap_all)) # only 133 are unique
OverlapHits_chr1_all <- gwas_overlap(chr1_overlap_all, all_p_cols)
##### no cent #####
# only keep the p value columns
hits_fdr_chr2 <- th_noelev_nocent[(th_noelev_nocent$chr == 2), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr2_overlap_nc <- id_snps(hits_fdr_chr2)
#271 elements
length(unique(chr2_overlap_nc)) # 103 unique
# check for overlap between gwas types
OverlapHits_chr2_nc <- gwas_overlap(chr2_overlap_nc, nc_p_cols)
# empty list :(
##### all  #####
# only keep the p value columns
hits_fdr_chr2_a <- th_noelev_all[(th_noelev_all$chr == 2), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr2_overlap_all <- id_snps(hits_fdr_chr2_a) # 306 elements
length(unique(chr2_overlap_all)) # 118 are unique
# fancy function 2
OverlapHits_chr2_all <- gwas_overlap(chr2_overlap_all, all_p_cols)
# empty list
##### no cent #####
# only keep the p value columns
hits_fdr_chr3 <- th_noelev_nocent[(th_noelev_nocent$chr == 3), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr3_overlap_nc <- id_snps(hits_fdr_chr3)
#628 elements
length(unique(chr3_overlap_nc)) # 272 unique
# check for overlap between gwas types
OverlapHits_chr3_nc <- gwas_overlap(chr3_overlap_nc, nc_p_cols)
# empty list :(
##### all  #####
# only keep the p value columns
hits_fdr_chr3_a <- th_noelev_all[(th_noelev_all$chr == 3), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr3_overlap_all <- id_snps(hits_fdr_chr3_a) # 758 elements
length(unique(chr3_overlap_all)) # 328 are unique
# fancy function 2
OverlapHits_chr3_all <- gwas_overlap(chr3_overlap_all, all_p_cols)
# empty list
##### no cent #####
# only keep the p value columns
hits_fdr_chr4 <- th_noelev_nocent[(th_noelev_nocent$chr == 4), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr4_overlap_nc <- id_snps(hits_fdr_chr4)
#only 36!
length(unique(chr4_overlap_nc)) # 17 unique
# check for overlap between gwas types
OverlapHits_chr4_nc <- gwas_overlap(chr4_overlap_nc, nc_p_cols)
# empty list :(
##### all  #####
# only keep the p value columns
hits_fdr_chr4_a <- th_noelev_all[(th_noelev_all$chr == 4), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr4_overlap_all <- id_snps(hits_fdr_chr4_a) # 43 elements
length(unique(chr4_overlap_all)) # 16 are unique
# fancy function 2
OverlapHits_chr4_all <- gwas_overlap(chr4_overlap_all, all_p_cols)
# empty list
##### no cent #####
# only keep the p value columns
hits_fdr_chr5 <- th_noelev_nocent[(th_noelev_nocent$chr == 5), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr5_overlap_nc <- id_snps(hits_fdr_chr5)
#624 elements!
length(unique(chr5_overlap_nc)) # 278 unique - wow that cut down a lot
# check for overlap between gwas types
OverlapHits_chr5_nc <- gwas_overlap(chr5_overlap_nc, nc_p_cols)
# list of 8!
##### all  #####
# only keep the p value columns
hits_fdr_chr5_a <- th_noelev_all[(th_noelev_all$chr == 5), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_all), value = TRUE), "min", "max")]
# fancy function I wrote
chr5_overlap_all <- id_snps(hits_fdr_chr5_a) #  1191 elements - something going on in this centromere
length(unique(chr5_overlap_all)) # 602 are unique
# fancy function 2
OverlapHits_chr5_all <- gwas_overlap(chr5_overlap_all, all_p_cols)
# list of 11!
# make a list of all the SNPs overlapping at all here to highlight in a GWAS figure.
shared_snps <- unique(c(OverlapHits_chr5_all[[1]]$rs, OverlapHits_chr5_all[[3]]$rs, OverlapHits_chr5_all[[8]]$rs, OverlapHits_chr5_all[[9]]$rs, OverlapHits_chr5_nc[[1]]$rs, OverlapHits_chr5_nc[[4]]$rs, OverlapHits_chr5_nc[[5]]$rs, OverlapHits_chr5_nc[[6]]$rs))
# list of all the files I am interested in
files <- c("NoCent.PlinkFiltering_Binary.c", "NoCent.PlinkFiltering_raw.c",  "NoCent.PlinkFiltering_Asin.c", "NoCent.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Asin.c", "allSNPs.PlinkFiltering_raw.c", "allSNPs.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Binary.c", "allSNPs.PlinkFiltering_raw_subset.c", "NoCent.PlinkFiltering_raw_subset.c")
highlight_snps <- function(identifier){
filename = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/", identifier, ".assoc.txt")
mplot_name = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/mplot_topSNPs/mplot_window_", identifier, "_highlight_Jul122023.png")
results <- read.delim(file= filename, header = T, stringsAsFactors = F)
##### Manhattan plot with qqman #####
png(mplot_name)
manhattan(x = results, chr = "chr", bp  = "ps", p = "p_wald", snp = "rs", highlight = shared_snps)
dev.off()
print(paste0("Done making plots for: ", identifier))
}
for (i in 1:length(files)){
highlight_snps(files[[i]])
}
library(emmeans)
library(lme4)
library(dplyr)
library(rcompanion) ## for plotNormalHistogram and blom functions (really don't need anymore if use hist() function)
library(MASS) ## for boxcox transformation
library(bestNormalize)
library(ggplot2)
library(dplyr)
library(qqman)
for (i in 1:length(files)){
highlight_snps(files[[i]])
}
shared_snps
knitr::opts_chunk$set(echo = TRUE)
# read in packages
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(qqman))
# list of all the files I am interested in
files <- c("NoCent.PlinkFiltering_Binary.c", "NoCent.PlinkFiltering_raw.c",  "NoCent.PlinkFiltering_Asin.c", "NoCent.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Asin.c", "allSNPs.PlinkFiltering_raw.c", "allSNPs.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Binary.c", "allSNPs.PlinkFiltering_raw_subset.c", "NoCent.PlinkFiltering_raw_subset.c")
# could then theoretically lapply my function to this list of names
# does not include the testing file b/c not needed here.
library(praise)
##### do it time 3 #####
# read in top hits file
top_hits_fdr_all <- read.csv("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/Top_hits_fdr_wald_Apr2023.csv")
#make a 1000bp window centered on the SNP
top_hits_fdr_all$min <- top_hits_fdr_all$ps - 500
top_hits_fdr_all$max <- top_hits_fdr_all$ps + 500
# problem with this code is that it gets rid of any row that has a value for elev even if it overlaps with a different one, so maybe just get rid of that column? but I really need to reduce rows to get an easier to read output... hm how to do this
# maybe I need to do it in two steps. first step would be to get rid of the columns, second step would be to get rid of rows that are all NAs
th_fdr_noelev <- top_hits_fdr_all[, grep("elev", colnames(top_hits_fdr_all), value = TRUE, invert = TRUE)]
# maybe to solve the problem of making sure the overlap is between two GWAS types, I should also only look at either all or NoCent at once
# using the 'inverse of all' code so the first three columns are also kept
th_noelev_nocent <- top_hits_fdr_all[, grep("all", colnames(th_fdr_noelev), value = TRUE, invert = TRUE)]
# using the 'inverse of nocent' code so the first three columns are also kept
th_noelev_all <- top_hits_fdr_all[, grep("nc", colnames(th_fdr_noelev), value = TRUE, invert = TRUE)]
# so count NAs, and  keep rows with fewer than 12 NAs (3 columns should have values for all rows)
th_noelev_nocent <- th_noelev_nocent[rowSums(is.na(th_noelev_nocent)) < 12 , ]
# sample size went way down!
th_noelev_all <- th_noelev_all[rowSums(is.na(th_noelev_all)) < 12 , ]
# nested loops that give me an output that is a list of dataframes with at least 2 overlapping SNPs in the window
id_snps <- function(input){
output <- list()
len <- length(input$ps) # to this point works
for (i in c(1:len)){
tmp_list <- c(input$min[i]:input$max[i])
tmp_df <- data.frame()
for (j in c(1:len)){
if (input$ps[j] %in% tmp_list) {
tmp_df <- rbind(tmp_df, input[j, ])}
}
if (length(tmp_df[,1]) > 1){
output <- append(output, list(tmp_df))}
}
return(output)
}
# function to identify if any of the overlapping regions are between at least 2 GWAS types
# issue with this function is that the columns to check will change depending on if it is an nc file or an all file
# I think this function might actually need a bit more testing
nc_p_cols <- c("p_binary_nc", "p_raw_nc", "p_asin_nc", "p_subset_nc")
all_p_cols <- c("p_binary_all", "p_raw_all", "p_asin_all", "p_subset_all")
gwas_overlap <- function(input, keep_cols){
cols_with_values <- c()
for(d in c(1:length(input))){
cols_with_values[d] <- sum(colSums(is.na(input[[d]][,keep_cols])) < length(input[[d]][ ,1]))
}
# then write out the dataframes from the initial list
output <- input[c(cols_with_values > 1)]
return(output)
}
##### no cent #####
# only keep the p value columns
hits_fdr_chr5 <- th_noelev_nocent[(th_noelev_nocent$chr == 5), c("chr", "rs", "ps", grep("p_", colnames(th_noelev_nocent), value = TRUE), "min", "max")]
# run that function!
chr5_overlap_nc <- id_snps(hits_fdr_chr5)
#624 elements!
length(unique(chr5_overlap_nc)) # 278 unique - wow that cut down a lot
# check for overlap between gwas types
OverlapHits_chr5_nc <- gwas_overlap(chr5_overlap_nc, nc_p_cols)
View(OverlapHits_chr5_nc)
View(chr5_overlap_nc)
View(hits_fdr_chr5)
View(hits_fdr_chr5)
