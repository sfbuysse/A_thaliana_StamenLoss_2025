geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3)+
geom_hline(yintercept = -log10(0.05), color = "blue", linetype = "dashed")+
geom_hline(yintercept = -log10(0.10), color = "yellow", linetype = "solid")+
scale_color_manual(values = rep(c("grey", "black"), 22)) +
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) +
labs(x="Chromosome", y= "-log10(bonferroni adjusted wald p)")+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
ggsave(paste0(mplot_name, "_bonf.png"), plot = mplot_bon, width = 7, height = 3, units = "in")
mplot <- ggplot(don, aes(x=psCum, y=-log10(P))) +
geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "blue", linetype = "dashed")+
#geom_hline(yintercept = -log10(sig.level), color = "red", linetype = "dotdash")+ # I want this to draw an fdr line
scale_color_manual(values = rep(c("grey", "black"), 22)) +
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= "-log10( wald P)")+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
ggsave(paste0(mplot_name,".png"), plot = mplot, width = 7, height = 3, units = "in")
print(paste0("Done making plots for: ", identifier))
}
files
##### Subset Raw Phenotypes #####
# only include if less than 2 as mean short stamen number
gwas_plots(type = "All", identifier = "allSNPs.PlinkFiltering_raw_subset.c")
gwas_plots(type = "All", identifier = "allSNPs.PlinkFiltering_raw.c")
gwas_plots(type = "NoCent", identifier = "NoCent.PlinkFiltering_raw.c")
gwas_plots(type = "NoCent", identifier = "NoCent.PlinkFiltering_raw_subset.c")
##### Asin Phenotypes #####
gwas_plots(type = "All", identifier = "allSNPs.PlinkFiltering_Asin.c")
gwas_plots(type = "NoCent", identifier = "NoCent.PlinkFiltering_Asin.c")
##### Binary Phenotypes #####
gwas_plots(type = "All", identifier = "allSNPs.PlinkFiltering_Binary.c")
gwas_plots(type = "NoCent", identifier = "NoCent.PlinkFiltering_Binary.c")
##### Elevation! #####
gwas_plots(type = "All", identifier = "allSNPs.PlinkFiltering_Elev.c")
gwas_plots(type = "NoCent", identifier = "NoCent.PlinkFiltering_Elev.c")
knitr::opts_chunk$set(echo = TRUE)
# for testing
identifier <- "allSNPs.PlinkFiltering_raw.c"
sig.level <- 0.05
filename = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/", identifier, ".assoc.txt")
fig_name = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/", identifier)
results <- read.delim(file= filename, header = T, stringsAsFactors = F)
forplot <- data.frame("BP" = results$ps, "CHR" = results$chr, "P" = results$p_wald, "SNP" = results$rs)
forplot$fdr <- p.adjust(p= forplot$P, method = "fdr")
#for point color...
forplot$fdr_col <- as.factor(CHR)
#for point color...
forplot$fdr_col <- as.factor(forplot$CHR)
forplot[forplot$fdr < 0.10, "fdr"] <- "B"
forplot <- data.frame("BP" = results$ps, "CHR" = results$chr, "P" = results$p_wald, "SNP" = results$rs)
forplot$fdr <- p.adjust(p= forplot$P, method = "fdr")
#for point color...
forplot$fdr_col <- as.factor(forplot$CHR)
forplot[forplot$fdr < 0.10, "fdr_col"] <- "B" # cutoff for this is between
forplot[forplot$fdr < 0.10, "fdr_col"] <- 6 # cutoff for this is between
#for point color...
forplot$fdr_col <- forplot$CHR
forplot[forplot$fdr < 0.10, "fdr_col"] <- 6 # cutoff for this is between
forplot[forplot$fdr < 0.05, "fdr_col"] <- 7
forplot$fdr_col <- as.factor(forplot$fdr_col)
View(forplot)
forplot$bon <- p.adjust(forplot$P, method = "bonferroni")
###### manual plot #####
# prep to plot
don <- forplot %>%
# compute chromosome size in bp
group_by(CHR) %>%
summarize(chr_len=max(BP)) %>%
#calculate cumulative position of each chromosome (again in bp)
mutate(tot=cumsum(chr_len)-chr_len) %>%
dplyr::select(-chr_len) %>%
#add this info to the initial data set (so like adding new column and sorting by it)
left_join(forplot, ., by=c("CHR"="CHR")) %>%
#add cum position of each SNP
arrange(CHR, BP) %>%
mutate( psCum=BP+tot)
axisdf = don %>% group_by(CHR) %>% summarize(center=( max(psCum) + min(psCum) ) /2 )
#sig.level is set in the function line. is 0.05 default but not expecting hits above that.
bonferroni_sig <- sig.level/length(forplot$P)
mplot <- ggplot(don, aes(x=psCum, y=-log10(P))) +
geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "blue", linetype = "dashed")+
#geom_hline(yintercept = -log10(fdr.line), color = "red", linetype = "dotdash")+
scale_color_manual(values = c("grey", "black", "grey", "black", "grey", "chartreuse", "darkorchid1"), 22)) +
mplot <- ggplot(don, aes(x=psCum, y=-log10(P))) +
geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "blue", linetype = "dashed")+
#geom_hline(yintercept = -log10(fdr.line), color = "red", linetype = "dotdash")+
scale_color_manual(values = c("grey", "black", "grey", "black", "grey", "chartreuse", "darkorchid1"), 22) +
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= "-log10( wald P)")+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
# merge manhattan and qq into a single thing??
qqplot <- qq(forplot$P)
library(ggpubr)
?ggarrange
# would need the package that let's me make multi facet figures
# then set 2/3 or 3/4 spaces as mplot, and one as qq, then save the merged file
final_fig <- ggarrange(fig, nrow = 1, ncol = 2, widths = c(3,1))
# would need the package that let's me make multi facet figures
# then set 2/3 or 3/4 spaces as mplot, and one as qq, then save the merged file
final_fig <- ggarrange(mplot, qqplot, nrow = 1, ncol = 2, widths = c(3,1))
ggsave(paste0(fig_name,".png"), plot = final_fig, width = 7, height = 3, dpi = 700, units = "in")
m_plot <- ggplot(don, aes(x=psCum, y=-log10(P))) +
geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "blue", linetype = "dashed")+
#geom_hline(yintercept = -log10(fdr.line), color = "red", linetype = "dotdash")+
scale_color_manual(values = c("grey", "black", "grey", "black", "grey", "chartreuse", "darkorchid1"), 22) +
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= "-log10( wald P)")+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
rm(mplot)
m_plot <- ggplot(don, aes(x=psCum, y=-log10(P))) +
geom_point( aes(color=fdr_col), alpha=0.8, size=1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "blue", linetype = "dashed")+
#geom_hline(yintercept = -log10(fdr.line), color = "red", linetype = "dotdash")+
scale_color_manual(values = c("grey", "black", "grey", "black", "grey", "chartreuse", "darkorchid1"), 22) +
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= "-log10( wald P)")+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
# would need the package that let's me make multi facet figures
# then set 2/3 or 3/4 spaces as mplot, and one as qq, then save the merged file
final_fig <- ggarrange(m_plot, qqplot, nrow = 1, ncol = 2, widths = c(3,1))
?qq
# merge manhattan and qq into a single thing??
qqplot <- qqman::qq(forplot$P)
qqnorm(forplot$BP)
m_plot <- ggplot(don, aes(x=psCum, y=-log10(P))) +
geom_point( aes(color=fdr_col), alpha=0.8, size=1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "blue", linetype = "dashed")+
#geom_hline(yintercept = -log10(fdr.line), color = "red", linetype = "dotdash")+
scale_color_manual(values = c("grey", "black", "grey", "black", "grey", "chartreuse", "darkorchid1"), 22) +
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= "-log10( wald P)")+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
m_plot <- ggplot(don, aes(x=psCum, y=-log10(P))) +
geom_point( aes(color=fdr_col), alpha=0.8, size=1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "blue", linetype = "dashed")+
#geom_hline(yintercept = -log10(fdr.line), color = "red", linetype = "dotdash")+
scale_color_manual(values = c("grey", "black", "grey", "black", "grey", "chartreuse", "darkorchid1"), 22) +
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= "-log10( wald P)")+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
ggsave(paste0(fig_name,".png"), plot = m_plot, width = 7, height = 3, dpi = 700, units = "in")
manhattan_highlight <- function(identifier, fdr.line, sig.level = 0.05){
##### Set filenames and read in file #####
filename = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/", identifier, ".assoc.txt")
fig_name = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/", identifier)
results <- read.delim(file= filename, header = T, stringsAsFactors = F)
# reorganize dataframe
forplot <- data.frame("BP" = results$ps, "CHR" = results$chr, "P" = results$p_wald, "SNP" = results$rs)
forplot$fdr <- p.adjust(p= forplot$P, method = "fdr")
#for point color...
forplot$fdr_col <- forplot$CHR
forplot[forplot$fdr < 0.10, "fdr_col"] <- 6
# allSNPs raw: cutoff for this is between 9.651559e-02 (6) and 1.004850e-01 (1)
forplot[forplot$fdr < 0.05, "fdr_col"] <- 7
# allSNPs raw: cutoff for this is between 7.323552e-02 (6) and 4.269675e-03(7)
forplot$fdr_col <- as.factor(forplot$fdr_col)
#make the shared hits a 0 or something??
forplot$bon <- p.adjust(forplot$P, method = "bonferroni")
###### manual plot #####
# prep to plot
don <- forplot %>%
# compute chromosome size in bp
group_by(CHR) %>%
summarize(chr_len=max(BP)) %>%
#calculate cumulative position of each chromosome (again in bp)
mutate(tot=cumsum(chr_len)-chr_len) %>%
dplyr::select(-chr_len) %>%
#add this info to the initial data set (so like adding new column and sorting by it)
left_join(forplot, ., by=c("CHR"="CHR")) %>%
#add cum position of each SNP
arrange(CHR, BP) %>%
mutate( psCum=BP+tot)
axisdf = don %>% group_by(CHR) %>% summarize(center=( max(psCum) + min(psCum) ) /2 )
#sig.level is set in the function line. is 0.05 default but not expecting hits above that.
bonferroni_sig <- sig.level/length(forplot$P)
# and plot. should just make the 1 plot.
m_plot <- ggplot(don, aes(x=psCum, y=-log10(P))) +
geom_point( aes(color=fdr_col), alpha=0.8, size=1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "blue", linetype = "dashed")+
#geom_hline(yintercept = -log10(fdr.line), color = "red", linetype = "dotdash")+
scale_color_manual(values = c("grey", "black", "grey", "black", "grey", "chartreuse", "darkorchid1"), 22) +
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= "-log10( wald P)")+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
## merge manhattan and qq into a single thing??
# this doesn't work as written because the ggplot is a grid object and the qqplot is not a grid object, so issues ensue.
#qqplot <- qqman::qq(forplot$P)
## would need the package that let's me make multi facet figures
## then set 2/3 or 3/4 spaces as mplot, and one as qq, then save the merged file
#final_fig <- ggarrange(m_plot, qqplot, nrow = 1, ncol = 2, widths = c(2,1))
##ggplot(forplot, aes(sample = P)+
##geom_qq()+
##geom_qq_line()+
##  labs(x = "Expected", y = "Observed")+
##  theme_bw()
ggsave(paste0(fig_name,".png"), plot = m_plot, width = 7, height = 3, dpi = 700, units = "in")
print(paste0("Done making plot for: ", identifier))
}
manhattan_highlight <- function(identifier, sig.level = 0.05){
# add fdr.line as an object?
##### Set filenames and read in file #####
filename = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/", identifier, ".assoc.txt")
fig_name = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/", identifier)
results <- read.delim(file= filename, header = T, stringsAsFactors = F)
# reorganize dataframe
forplot <- data.frame("BP" = results$ps, "CHR" = results$chr, "P" = results$p_wald, "SNP" = results$rs)
forplot$fdr <- p.adjust(p= forplot$P, method = "fdr")
#for point color...
forplot$fdr_col <- forplot$CHR
forplot[forplot$fdr < 0.10, "fdr_col"] <- 6
# allSNPs raw: cutoff for this is between 9.651559e-02 (6) and 1.004850e-01 (1)
forplot[forplot$fdr < 0.05, "fdr_col"] <- 7
# allSNPs raw: cutoff for this is between 7.323552e-02 (6) and 4.269675e-03(7)
forplot$fdr_col <- as.factor(forplot$fdr_col)
#make the shared hits a 0 or something??
forplot$bon <- p.adjust(forplot$P, method = "bonferroni")
###### manual plot #####
# prep to plot
don <- forplot %>%
# compute chromosome size in bp
group_by(CHR) %>%
summarize(chr_len=max(BP)) %>%
#calculate cumulative position of each chromosome (again in bp)
mutate(tot=cumsum(chr_len)-chr_len) %>%
dplyr::select(-chr_len) %>%
#add this info to the initial data set (so like adding new column and sorting by it)
left_join(forplot, ., by=c("CHR"="CHR")) %>%
#add cum position of each SNP
arrange(CHR, BP) %>%
mutate( psCum=BP+tot)
axisdf = don %>% group_by(CHR) %>% summarize(center=( max(psCum) + min(psCum) ) /2 )
#sig.level is set in the function line. is 0.05 default but not expecting hits above that.
bonferroni_sig <- sig.level/length(forplot$P)
# and plot. should just make the 1 plot.
m_plot <- ggplot(don, aes(x=psCum, y=-log10(P))) +
geom_point( aes(color=fdr_col), alpha=0.8, size=1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "blue", linetype = "dashed")+
#geom_hline(yintercept = -log10(fdr.line), color = "red", linetype = "dotdash")+
scale_color_manual(values = c("grey", "black", "grey", "black", "grey", "chartreuse", "darkorchid1"), 22) +
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= "-log10( wald P)")+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
## merge manhattan and qq into a single thing??
# this doesn't work as written because the ggplot is a grid object and the qqplot is not a grid object, so issues ensue.
#qqplot <- qqman::qq(forplot$P)
## would need the package that let's me make multi facet figures
## then set 2/3 or 3/4 spaces as mplot, and one as qq, then save the merged file
#final_fig <- ggarrange(m_plot, qqplot, nrow = 1, ncol = 2, widths = c(2,1))
##ggplot(forplot, aes(sample = P)+
##geom_qq()+
##geom_qq_line()+
##  labs(x = "Expected", y = "Observed")+
##  theme_bw()
ggsave(paste0(fig_name,".png"), plot = m_plot, width = 7, height = 3, dpi = 700, units = "in")
print(paste0("Done making plot for: ", identifier))
}
##### Raw Phenotypes #####
manhattan_highlight(identifier = "allSNPs.PlinkFiltering_raw.c")
manhattan_highlight(identifier = "NoCent.PlinkFiltering_raw.c")
##### Subset Raw Phenotypes #####
# only include if less than 2 as mean short stamen number
manhattan_highlight(identifier = "allSNPs.PlinkFiltering_raw_subset.c")
manhattan_highlight(identifier = "NoCent.PlinkFiltering_raw_subset.c")
##### Asin Phenotypes #####
manhattan_highlight(identifier = "allSNPs.PlinkFiltering_Asin.c")
manhattan_highlight(identifier = "NoCent.PlinkFiltering_Asin.c")
##### Binary Phenotypes #####
manhattan_highlight(identifier = "allSNPs.PlinkFiltering_Binary.c")
manhattan_highlight(identifier = "NoCent.PlinkFiltering_Binary.c")
##### Elevation! #####
manhattan_highlight(identifier = "allSNPs.PlinkFiltering_Elev.c")
manhattan_highlight(identifier = "NoCent.PlinkFiltering_Elev.c")
citation(ggpubr)
library(ggpubr)
citation(ggpubr)
citation('ggpubr')
knitr::opts_chunk$set(echo = TRUE)
packages_needed <- c("devtools","roxygen2")
for (i in 1:length(packages_needed)){
if(!(packages_needed[i] %in% installed.packages())){install.packages(packages_needed[i])}
}
for (i in 1:length(packages_needed)){
library( packages_needed[i], character.only = TRUE)
}
#document()
#setwd('../')
install('quaint')
document()
document()
?document()
document(pkg = "quaint")
document(pkg = "../")
install.packages('quaint')
#' Calculate Qpc
#'
#' This function calculates Qpc given data about the relatedness matrix, and a set of trait values
#' @param myZ vector of traits. Not normalized yet.
#' @param myU matrix of eigenvectors of the kinship matrix (each column is an eigenvector)
#' @param myLambdas vector of eigenvalues of the kinship matrix
#' @param myM the range of PCs you want to test for selection
#' @param myL the range of PCs used to estimate Va
#' @export
#' @examples
#' calcQpc()
calcQpc <- function(myZ, myU, myLambdas, myL, myM){
myZ = myZ[1:dim(myU)[1]] - mean(myZ) #mean center phenotypes
myCmM = (myZ %*% myU[,myM])/sqrt(myLambdas[myM]) #project + standardize by the eigenvalues for testing for selection
myCmL = (myZ %*% myU[,myL])/sqrt(myLambdas[myL]) #project + standardize by the eigenvalues for estimating Va
myQm = sapply(myM, function(n){var0(myCmM[n])/var0(myCmL) })  #test for selection
myPs = sapply(myM, function(x){pf(myQm[x], 1, length(myL), lower.tail=F)}) #get a pvalue
retdf = list(cm = myCmM, cml = myCmL, qm = myQm, pvals = myPs)
return(retdf)
}
#' Calculate Qpc
#'
#' This function calculates Qpc given data about the relatedness matrix, and a set of trait values
#' @param myZ vector of traits. Not normalized yet.
#' @param myU matrix of eigenvectors of the kinship matrix (each column is an eigenvector)
#' @param myLambdas vector of eigenvalues of the kinship matrix
#' @param myM the range of PCs you want to test for selection
#' @param myL the range of PCs used to estimate Va
#' @export
#' @examples
#' calcQpc()
calcQpc <- function(myZ, myU, myLambdas, myL, myM){
myZ = myZ[1:dim(myU)[1]] - mean(myZ) #mean center phenotypes
myCmM = (myZ %*% myU[,myM])/sqrt(myLambdas[myM]) #project + standardize by the eigenvalues for testing for selection
myCmL = (myZ %*% myU[,myL])/sqrt(myLambdas[myL]) #project + standardize by the eigenvalues for estimating Va
myQm = sapply(myM, function(n){var0(myCmM[n])/var0(myCmL) })  #test for selection
myPs = sapply(myM, function(x){pf(myQm[x], 1, length(myL), lower.tail=F)}) #get a pvalue
retdf = list(cm = myCmM, cml = myCmL, qm = myQm, pvals = myPs)
return(retdf)
}
#' Calculate conditional Qpc
#'
#' This function calculates Qpc given data about the relatedness matrix, and a set of trait values
#' @param myZ two columned data frame containing vectors of two traits. Not normalized yet. The first trait is the one we're testing for selection on conditional on the second trait.
#' @param myU matrix of eigenvectors of the kinship matrix (each column is an eigenvector)
#' @param myLambdas vector of eigenvalues of the kinship matrix
#' @param myM the range of PCs you want to test for selection
#' @param myL the range of PCs used to estimate Va
#' @export
#' @examples
#' calcQpc()
condQpc <- function(myZ,myU, myLambdas, myM, myL){
# get Xms for each PC (for Z1, the focal trait and Z2, the correlated trait) THESE ARE MEAN CENTERED
myX1centered = (myZ[-nrow(myZ),1]-mean(myZ[,1]))%*%myU/sqrt(myLambdas)
myX2centered = (myZ[-nrow(myZ),2]-mean(myZ[,2]))%*%myU/sqrt(myLambdas)
#get mu' for each PC
Ca12 = sum(myX1centered[myL]*myX2centered[myL])/length(myL) #is this the right way to do this??
Va2 = (sum(myX2centered[myL]^2))/length(myL)
Va1 = sum(myX1centered[myL]^2)/length(myL)
mu1cond = mean(myZ[-nrow(myZ),1]) + (Ca12/Va2)*(myZ[-nrow(myZ),2] - mean(myZ[,2])) #one value for each individual
va1cond = Va1 - (Ca12^2)/Va2
#now test for selection
myQ = ((myZ[-nrow(myZ),1]-mu1cond)%*%myU[,myM])/sqrt(myLambdas[myM]*va1cond) #get a vector of the projections that we'll test
#under neutrality, my Q ~ N(0,1)
return(myQ)
}
#' Kinship matrix function for complete data using the estimated variance across all loci
#'
#' This function makes a kinship matrix using the cov function. It standardizes by the estimated genic variance across all loci, not each locus individually
#' @param myG matrix where the rows are individuals/populations and the columns are loci and the values are the allele frequency (not the # of copies present in an individual!!!).
#' @export
make_k <- function (myG)
{
scaleFactor = sqrt(mean(colMeans(myG) * (1 - colMeans(myG))))
myM = dim(myG)[1]
myT = matrix(data = -1/myM, nrow = myM - 1, ncol = myM)
diag(myT) = (myM - 1)/myM
myGstand = (myT %*% myG)/scaleFactor
myK = cov(t(myGstand))
return(myK)
}
#' Calculate variance where the mean is set to zero
#'
#' This function takes a string of numbers and calculates the variance of these numbers, assuming that the mean is 0.
#' @param x a string of vectors
#' @export
var0 <- function(x){  #variance where mean is set to 0
return(sum(x^2)/length(x))
}
library(viridis)
getwd()
# start with example data?
load("Downloads/1001-matrix-50Ksamp.rda")
# start with example data?
load("C:/Users/Sophie/Downloads/1001-matrix-50Ksamp.rda")
head(myGt)
head(myGt)[5,5]
head(myGt)[1:5,1:5]
# load in my data
load("data/GenotypeMatrix_Cent_50k_Aug2023.ROBJ")
load("data/RawPhenotypes_Aug2023/ROBJ")
load("data/RawPhenotypes_Aug2023.ROBJ")
allData <- read.csv("C:/Users/Sophie/Downloads/1001genomes-FT10-FT16 and 1001genomes-accessions.csv', stringsAsFactors = F")
allData <- read.csv("C:/Users/Sophie/Downloads/1001genomes-FT10-FT16 and 1001genomes-accessions.csv', stringsAsFactors = F")
allData <- read.csv("C:/Users/Sophie/Downloads/1001genomes-FT10-FT16 and 1001genomes-accessions.csv", stringsAsFactors = F)
# get rid of missing data
allDataFT16 = dplyr::filter(allData, is.na(FT16_mean) == FALSE)
View(pheno2)
head(cent_sub)
# pull out genotype data fro individuals with phenotypes
combinedData = dplyr::inner_join(allDataFT16, myGt, by='id')
myG = combinedData[,-c(1:17)]
myTraits = combinedData[,1:17]
# example data
myK - make)k(as.matrix(myG))
# example data
myK <- make)k(as.matrix(myG))
# example data
myK <- make_k(as.matrix(myG))
head(myK)[1:5, 1:5]
head(myG)[1:5, 1:5]
# do eigen decomposition
myEig <- eigen(myK)
# plot the first two PCs
plot(myEig$vectors[,1], myEig$vectors[,2], bty="n", xlab = "PC1", ylab = "PC2", col = '#FF5300')
# plot pve
plot(myEig$values/sum(myEig$values)*100, col = "#43B629", bty="n", ylab = "% variation explained by each PC", xlab = "PC")
plot(-log10(myQpc$pvals), bty="n", xlab = "PCs", ylab = "-log10(p value)", col = "#1BB6AF", lwd=2, xaxt="n")
# example data
myQpc <- calcQpc(myZ = myTraits$FT16_mean,
myU = myEig$vectors,
myLambdas = myEig$values,
myM = 1:10,
myL = 485:969)
# example data
plot(-log10(myQpc$pvals), bty="n", xlab = "PCs", ylab = "-log10(p value)", col = "#1BB6AF", lwd=2, xaxt="n")
abline(h = -log10(0.05/length(myQpc$pvals)), col = "#FF5300", lwd=2)
axis(1, at = c(1:length(myQpc$pvals)))
#estimate the confidence intervals
myVaest = var0(myQpc$cml)
myCI = 1.96*sqrt(myVaest*myEig$values)
#plot
palette(c('white','#999999', '#E69F00', '#56B4E9', "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", 'black', 'mediumpurple3'))
par(mar = c(5,8,5,14), xpd=T)
plot(myEig$vectors[,2], myTraits$FT16_mean[-nrow(myTraits)], bty="n", col = as.factor(myTraits$group), lwd=2, ylab = "", yaxt="n",xlab = "PC2", cex.lab=2, cex.axis=2, xaxt="n")
axis(1, cex.axis=1.5, lwd=2)
axis(2, las=2, cex.axis=1.5, lwd=2)
mtext('Flowering time 16C',side=2, line=5, cex=2)
legend(0.06, 130, levels(as.factor(myTraits$group)), pch=1, pt.lwd = 2,col = palette(), bty="n", text.width = 0.04)
par(xpd=F)
abline(lm(myTraits$FT16_mean[-nrow(myTraits)]~myEig$vectors[,2]), lwd=2, col = "#0072B2")
abline(a=mean(myTraits$FT16_mean), b = myCI[2], lty=2, col='#56B4E9', lwd=2)
abline(a=mean(myTraits$FT16_mean), b = -myCI[2], lty=2, col='#56B4E9', lwd=2)
