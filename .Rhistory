mutate(seSSN = sdSSN / sqrt(NumFlwr))
# 10
mean(PerLine$seSSN, na.rm = TRUE)
#99.5
mean(PerPop$seSSN, na.rm = TRUE)
summary(PerPop)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(qqman)
library(ggpubr)
rm(list = ls())
# list of files to read in :
files <- c("NoCent.PlinkFiltering_Binary.c", "NoCent.PlinkFiltering_raw.c",  "NoCent.PlinkFiltering_Asin.c", "NoCent.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Asin.c", "allSNPs.PlinkFiltering_raw.c", "allSNPs.PlinkFiltering_Elev.c", "allSNPs.PlinkFiltering_Binary.c", "allSNPs.PlinkFiltering_raw_subset.c", "NoCent.PlinkFiltering_raw_subset.c","NoCent.PlinkFiltering_raw.c_testing" )
# list of plot labels
mplot_label <- c("figs7c", "figs7a", "figs6a", "figx", "fig4a", "figs4a", "figxx", "figs4c", "figs4e", "figs7e", "figxxx")
#qplot_label <- c("figs7e", "figs7b", "figs6b", "fig2x", "fig4b", "figs4b", "fig2xx", "figs4d", "figs4f", "figs7f", "fig2xxx")
# list of label to write on plot
mplot_letter <- c("B", "A", "A", "X", "A", "A", "X", "B", "C", "C", "X")
#mplot_letter <- c("C", "A", "A", "X", "A", "A", "X", "C", "E", "E", "X")
#qplot_letter <- c("D", "B", "B", "X", "B", "B", "X", "D", "F", "F", "X")
# list of shared SNPs - there are two lists for hits shared between cent included analyses and between cent excluded analyses with no overlap of the SNPs that are a hit in cent and no cent for the same type of GWAS - there is 1 hit window only in cent and a different one only in no cent
# Cent only shared snps
# on 1/29/2024 I remade these figures because I had only been including SNPs where the exact SNP was >0.10 in both analyses and ignoring the whole windowed analysis thing that I did. So a few more SNPs to highlight!
cent <- c("Chr1:14262517",
"Chr3:2239234",
"Chr3:2253161",
"Chr3:2942726",
"Chr5:4899729",
"Chr5:4899733",
"Chr5:4899789",
"Chr5:4899798",
"Chr5:4899803",
"Chr5:4899865",
"Chr5:4900275",
"Chr5:4900560",
"Chr5:4900628",
"Chr5:4919727",
"Chr5:4920179",
"Chr5:4920289",
"Chr5:4920304",
"Chr5:4920731",
"Chr5:10731997",
"Chr5:13458838"
)
# no cent only shared SNPs
nocent <- c("Chr3:2239234",
"Chr3:2253161",
"Chr3:2942726",
"Chr5:4899789",
"Chr5:4899798",
"Chr5:4899803",
"Chr5:4900275",
"Chr5:4900560",
"Chr5:4919727",
"Chr5:4920179",
"Chr5:4920289",
"Chr5:4920304",
"Chr5:4920731",
"Chr5:10731997",
"Chr5:13458838",
"Chr5:19462189"
)
# for testing
#identifier <- "allSNPs.PlinkFiltering_asin.c"
#identifier <- "allSNPs.PlinkFiltering_Elev.c"
#sig.level <- 0.05
manhattan_highlight <- function(identifier, sig.level = 0.05, type, i){
# add fdr.line as an object?
##### Set filenames and read in file #####
filename = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/", identifier, ".assoc.txt")
fig_name = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/", identifier)
results <- read.delim(file= filename, header = T, stringsAsFactors = F)
# reorganize dataframe
forplot <- data.frame("BP" = results$ps, "CHR" = results$chr, "P" = results$p_wald, "SNP" = results$rs)
forplot$fdr <- p.adjust(p= forplot$P, method = "fdr")
#for point color...
forplot$fdr_col <- forplot$CHR
forplot[forplot$fdr_col == 1, "fdr_col"] <- "#ABABAB"
forplot[forplot$fdr_col == 2, "fdr_col"] <- "#000000"
forplot[forplot$fdr_col == 3, "fdr_col"] <- "#ABABAB"
forplot[forplot$fdr_col == 4, "fdr_col"] <- "#000000"
forplot[forplot$fdr_col == 5, "fdr_col"] <- "#ABABAB"
forplot[forplot$fdr < 0.10, "fdr_col"] <- "#1E88E5"
# allSNPs raw: cutoff for this is between 9.651559e-02 (6) and 1.004850e-01 (1)
forplot[forplot$fdr < 0.05, "fdr_col"] <- "#D66C93"
# allSNPs raw: cutoff for this is between 7.323552e-02 (6) and 4.269675e-03(7)
forplot$fdr_col <- as.factor(forplot$fdr_col)
#make the shared hits a 0 or something??
# add bonferroni correction p value
forplot$bon <- p.adjust(forplot$P, method = "bonferroni")
# add row for outlining shared SNPs
forplot$shared <- as.character(alpha(forplot$fdr_col, 0))
forplot[forplot$SNP %in% type, "shared"] <- alpha("green", 1)
forplot$shared <- as.factor(forplot$shared)
###### manual plot #####
# prep to plot
don <- forplot %>%
# compute chromosome size in bp
group_by(CHR) %>%
summarize(chr_len=max(BP)) %>%
#calculate cumulative position of each chromosome (again in bp)
mutate(tot=cumsum(chr_len)-chr_len) %>%
dplyr::select(-chr_len) %>%
#add this info to the initial data set (so like adding new column and sorting by it)
left_join(forplot, ., by=c("CHR"="CHR")) %>%
#add cum position of each SNP
arrange(CHR, BP) %>%
mutate( psCum=BP+tot)
axisdf = don %>% group_by(CHR) %>% summarize(center=( max(psCum) + min(psCum) ) /2 )
#sig.level is set in the function line. is 0.05 default but not expecting hits above that.
bonferroni_sig <- sig.level/length(forplot$P)
# and plot. should just make the 1 plot.
# split don into shared SNPs and not shared SNPs, then merging together so the shared snps are at the bottom of the dataframe and will be plotted on top of the other points.
don_a <- don[don$shared == "#00FF00FF", ]
don_b <- don[don$shared != "#00FF00FF", ]
don_c <- rbind(don_b, don_a)
# start plot with don_b becuase that is most of what I'll need
mplot <- ggplot(don_c, aes(x=psCum, y=-log10(P))) +
geom_point(aes(fill = fdr_col, color = shared), shape = 21, size = 1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "#FFC107", linetype = "dashed", alpha = 0.6)+
geom_segment(aes(x = 21551000, y = -0.3, xend = 30245000, yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x = (50122495+7329000), y = -0.3, xend = (50122495+ 8201000), yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x =(92167091+2408000 ), y = -0.3, xend = (92167091+2986000 ), yend = -0.3), col = "black", lineend = "round")+
scale_fill_manual(values = alpha(levels(don_c$fdr_col),0.8)) +
scale_color_manual(values = levels(don_c$shared))+
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= bquote(-log[10](p)))+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
## merge manhattan and qq into a single thing??
# this doesn't work as written because the ggplot is a grid object and the qqplot is not a grid object, so issues ensue.
#qqplot <- qqman::qq(forplot$P)
## would need the package that let's me make multi facet figures
## then set 2/3 or 3/4 spaces as mplot, and one as qq, then save the merged file
#final_fig <- ggarrange(m_plot, qqplot, nrow = 1, ncol = 2, widths = c(2,1))
##ggplot(forplot, aes(sample = P)+
##geom_qq()+
##geom_qq_line()+
##  labs(x = "Expected", y = "Observed")+
##  theme_bw()
mplot <- annotate_figure(mplot,
fig.lab = mplot_letter[i], fig.lab.face = "bold")
#annotate_figure(qplot_label[i],
#              fig.lab = qplot_letter[i], fig.lab.face = "bold")
ggsave(paste0(fig_name,".png"), plot = mplot, width = 7, height = 3, dpi = 700, units = "in")
print(paste0("Done making plot for: ", identifier))
}
# going with this for now (11/3/2023) but I do think I could plot the shared ones as a second layer and then they would all be on the top rather than covered by some other points.
# there might also be a slighly overlap between color and fill that is creating a dark outline because both are at least somewhat transparent. Maybe I need to decrease size so it isn't 1.3?
manhattan_highlight_NoPink <- function(identifier, sig.level = 0.05, type, i){
# add fdr.line as an object?
##### Set filenames and read in file #####
filename = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/", identifier, ".assoc.txt")
fig_name = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/", identifier)
results <- read.delim(file= filename, header = T, stringsAsFactors = F)
# reorganize dataframe
forplot <- data.frame("BP" = results$ps, "CHR" = results$chr, "P" = results$p_wald, "SNP" = results$rs)
forplot$fdr <- p.adjust(p= forplot$P, method = "fdr")
#for point color...
forplot$fdr_col <- forplot$CHR
forplot[forplot$fdr_col == 1, "fdr_col"] <- "#ABABAB"
forplot[forplot$fdr_col == 2, "fdr_col"] <- "#000000"
forplot[forplot$fdr_col == 3, "fdr_col"] <- "#ABABAB"
forplot[forplot$fdr_col == 4, "fdr_col"] <- "#000000"
forplot[forplot$fdr_col == 5, "fdr_col"] <- "#ABABAB"
forplot[forplot$fdr < 0.10, "fdr_col"] <- "#1E88E5"
# allSNPs raw: cutoff for this is between 9.651559e-02 (6) and 1.004850e-01 (1)
forplot$fdr_col <- as.factor(forplot$fdr_col)
#make the shared hits a 0 or something??
# add bonferroni correction p value
forplot$bon <- p.adjust(forplot$P, method = "bonferroni")
# add row for outlining shared SNPs
forplot$shared <- as.character(alpha(forplot$fdr_col, 0))
forplot[forplot$SNP %in% type, "shared"] <- alpha("green", 1)
forplot$shared <- as.factor(forplot$shared)
###### manual plot #####
# prep to plot
don <- forplot %>%
# compute chromosome size in bp
group_by(CHR) %>%
summarize(chr_len=max(BP)) %>%
#calculate cumulative position of each chromosome (again in bp)
mutate(tot=cumsum(chr_len)-chr_len) %>%
dplyr::select(-chr_len) %>%
#add this info to the initial data set (so like adding new column and sorting by it)
left_join(forplot, ., by=c("CHR"="CHR")) %>%
#add cum position of each SNP
arrange(CHR, BP) %>%
mutate( psCum=BP+tot)
axisdf = don %>% group_by(CHR) %>% summarize(center=( max(psCum) + min(psCum) ) /2 )
#sig.level is set in the function line. is 0.05 default but not expecting hits above that.
bonferroni_sig <- sig.level/length(forplot$P)
# and plot. should just make the 1 plot.
# split don into shared SNPs and not shared SNPs, then merging together so the shared snps are at the bottom of the dataframe and will be plotted on top of the other points.
don_a <- don[don$shared == "#00FF00FF", ]
don_b <- don[don$shared != "#00FF00FF", ]
don_c <- rbind(don_b, don_a)
# start plot with don_b becuase that is most of what I'll need
mplot <- ggplot(don_c, aes(x=psCum, y=-log10(P))) +
geom_point(aes(fill = fdr_col, color = shared), shape = 21, size = 1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "#FFC107", linetype = "dashed", alpha = 0.6)+
geom_segment(aes(x = 21551000, y = -0.3, xend = 30245000, yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x = (50122495+7329000), y = -0.3, xend = (50122495+ 8201000), yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x =(92167091+2408000 ), y = -0.3, xend = (92167091+2986000 ), yend = -0.3), col = "black", lineend = "round")+
scale_fill_manual(values = alpha(levels(don_c$fdr_col),0.8)) +
scale_color_manual(values = levels(don_c$shared))+
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= bquote(-log[10](p)))+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
## merge manhattan and qq into a single thing??
# this doesn't work as written because the ggplot is a grid object and the qqplot is not a grid object, so issues ensue.
#qqplot <- qqman::qq(forplot$P)
## would need the package that let's me make multi facet figures
## then set 2/3 or 3/4 spaces as mplot, and one as qq, then save the merged file
#final_fig <- ggarrange(m_plot, qqplot, nrow = 1, ncol = 2, widths = c(2,1))
##ggplot(forplot, aes(sample = P)+
##geom_qq()+
##geom_qq_line()+
##  labs(x = "Expected", y = "Observed")+
##  theme_bw()
mplot <- annotate_figure(mplot,
fig.lab = mplot_letter[i], fig.lab.face = "bold")
#annotate_figure(qplot_label[i],
#              fig.lab = qplot_letter[i], fig.lab.face = "bold")
ggsave(paste0(fig_name,".png"), plot = mplot, width = 7, height = 3, dpi = 700, units = "in")
print(paste0("Done making plot for: ", identifier))
}
manhattan_highlight_NoPink(identifier = "allSNPs.PlinkFiltering_Asin.c", type = cent, i=5)
manhattan_highlight_NoPink <- function(identifier, sig.level = 0.05, type, i){
# add fdr.line as an object?
##### Set filenames and read in file #####
filename = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/GemmaOutput_2022/", identifier, ".assoc.txt")
fig_name = paste0("C:/Users/Sophie/Michigan State University/Conner, Jeffrey - SophieAnalyses/Figures/ManuscriptFigs/", identifier)
results <- read.delim(file= filename, header = T, stringsAsFactors = F)
# reorganize dataframe
forplot <- data.frame("BP" = results$ps, "CHR" = results$chr, "P" = results$p_wald, "SNP" = results$rs)
forplot$fdr <- p.adjust(p= forplot$P, method = "fdr")
#for point color...
forplot$fdr_col <- forplot$CHR
forplot[forplot$fdr_col == 1, "fdr_col"] <- "#ABABAB"
forplot[forplot$fdr_col == 2, "fdr_col"] <- "#000000"
forplot[forplot$fdr_col == 3, "fdr_col"] <- "#ABABAB"
forplot[forplot$fdr_col == 4, "fdr_col"] <- "#000000"
forplot[forplot$fdr_col == 5, "fdr_col"] <- "#ABABAB"
forplot[forplot$fdr < 0.10, "fdr_col"] <- "#1E88E5"
# allSNPs raw: cutoff for this is between 9.651559e-02 (6) and 1.004850e-01 (1)
forplot$fdr_col <- as.factor(forplot$fdr_col)
#make the shared hits a 0 or something??
# add bonferroni correction p value
forplot$bon <- p.adjust(forplot$P, method = "bonferroni")
# add row for outlining shared SNPs
forplot$shared <- as.character(alpha(forplot$fdr_col, 0))
forplot[forplot$SNP %in% type, "shared"] <- alpha("green", 1)
forplot$shared <- as.factor(forplot$shared)
###### manual plot #####
# prep to plot
don <- forplot %>%
# compute chromosome size in bp
group_by(CHR) %>%
summarize(chr_len=max(BP)) %>%
#calculate cumulative position of each chromosome (again in bp)
mutate(tot=cumsum(chr_len)-chr_len) %>%
dplyr::select(-chr_len) %>%
#add this info to the initial data set (so like adding new column and sorting by it)
left_join(forplot, ., by=c("CHR"="CHR")) %>%
#add cum position of each SNP
arrange(CHR, BP) %>%
mutate( psCum=BP+tot)
axisdf = don %>% group_by(CHR) %>% summarize(center=( max(psCum) + min(psCum) ) /2 )
#sig.level is set in the function line. is 0.05 default but not expecting hits above that.
bonferroni_sig <- sig.level/length(forplot$P)
# and plot. should just make the 1 plot.
# split don into shared SNPs and not shared SNPs, then merging together so the shared snps are at the bottom of the dataframe and will be plotted on top of the other points.
don_a <- don[don$shared == "#00FF00FF", ]
don_b <- don[don$shared != "#00FF00FF", ]
don_c <- rbind(don_b, don_a)
# start plot with don_b becuase that is most of what I'll need
mplot <- ggplot(don_c, aes(x=psCum, y=-log10(P))) +
geom_point(aes(fill = fdr_col, color = shared), shape = 21, size = 1.3)+
geom_hline(yintercept = -log10(bonferroni_sig), color = "#FFC107", linetype = "dashed", alpha = 0.6)+
geom_segment(aes(x = 21551000, y = -0.3, xend = 30245000, yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x = (50122495+7329000), y = -0.3, xend = (50122495+ 8201000), yend = -0.3), col = "black", lineend = "round")+
geom_segment(aes(x =(92167091+2408000 ), y = -0.3, xend = (92167091+2986000 ), yend = -0.3), col = "black", lineend = "round")+
scale_fill_manual(values = alpha(levels(don_c$fdr_col),0.8)) +
scale_color_manual(values = levels(don_c$shared))+
scale_x_continuous( label = axisdf$CHR, breaks = axisdf$center ) +
#scale_y_continuous(expand = c(0,0), limits = c(0, ylim)) + # might add this back in later for better comparison
labs(x="Chromosome", y= bquote(-log[10](p)))+
theme_bw() +
theme(
legend.position="none",
panel.border = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
)
mplot <- annotate_figure(mplot,
fig.lab = mplot_letter[i], fig.lab.face = "bold")
#annotate_figure(qplot_label[i],
#              fig.lab = qplot_letter[i], fig.lab.face = "bold")
ggsave(paste0(fig_name,"_NoPink.png"), plot = mplot, width = 7, height = 3, dpi = 700, units = "in")
print(paste0("Done making NoPink plot for: ", identifier))
}
manhattan_highlight(identifier = "allSNPs.PlinkFiltering_Asin.c", type = cent, i=5)
# adding no pink version because hard to see in manuscript draft and reviews agree - only see green outline
manhattan_highlight_NoPink(identifier = "allSNPs.PlinkFiltering_Asin.c", type = cent, i=5)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
ByFlwr <- read.csv("data/SpanishMasterDataset_ByFlwr.csv")
# Tube is equivalent to the time point, so 1 is the first 10 ish flowers, 2 is from around the 20th flower produced, and 3 is around the 30th flower produced and that is why there are multiples from tube b/c multiple flowers collected at each time point
ByFlwr$Population <- as.factor(substr(ByFlwr$Population, start = 1, stop = 3))
ByFlwr$Matriline <- as.factor(ByFlwr$Matriline)
ByFlwr$Plant <- as.factor(ByFlwr$Plant)
ByFlwr$LineID <- as.factor(paste0(ByFlwr$Population, "-", ByFlwr$Matriline))
ByFlwr$PlantID <- as.factor(paste0(ByFlwr$LineID, "-", ByFlwr$Plant))
uids <- unique(ByFlwr$PlantID)
length(uids)
# 230 plants were phenotyped
# Make a unique ID for each flower in the dataset
flwr<-c()
for(i in 1:length(uids)){
len<-length(ByFlwr$PlantID[ByFlwr$PlantID==uids[i]])
flwr<-append(flwr,seq(1,len,1))
}
ByFlwr$flower<-flwr
ByFlwr$FlowerID <- paste0(ByFlwr$PlantID, "-", ByFlwr$flower)
dat_all <- ByFlwr[,c("Population", "LineID", "PlantID", "FlowerID", "NumShortStamens", "Notes")]
# How many planting blocks?
length(unique(ByFlwr$PlantingBlock))
# How many unique lines?
length(unique(dat_all$LineID))
# How many lines per population?
PerPop <- dat_all %>% group_by(Population) %>%
summarize(NumLines = length(unique(LineID)), NumPlants = length(unique(PlantID)), NumFlwr = length(unique(FlowerID)), meanSSN = mean(NumShortStamens), sdSSN = sd(NumShortStamens))
PerPop <- PerPop %>%
mutate(seSSN = sdSSN / sqrt(NumFlwr))
# there are 5 to 9 lines per pop
# want flowers per pop info b/c that is what is used for population means
summary(PerPop)
min(PerPop$NumFlwr)
# 42
max(PerPop$NumFlwr)
#168
mean(PerPop$NumFlwr)
# 88.9
median(PerPop$NumFlwr)
#99.5
mean(PerPop$seSSN, na.rm = TRUE)
#0.05752545
# How many Plants and Flowers per line?
PerLine <- dat_all %>% group_by(LineID) %>%
summarize(NumPlants = length(unique(PlantID)), NumFlwr = length(unique(FlowerID)), meanSSN = mean(NumShortStamens), sdSSN = sd(NumShortStamens))
PerLine <- PerLine %>%
mutate(seSSN = sdSSN / sqrt(NumFlwr))
summary(PerLine)
min(PerLine$NumPlants)
# 1
max(PerLine$NumPlants)
# 4
mean(PerLine$NumPlants)
# 2.05
median(PerLine$NumPlants)
# 2
min(PerLine$NumFlwr)
# 1 -- only 1 flower for 1 plant for this line
# this is true for POB-10 and POB-19. both of them are also sequenced
max(PerLine$NumFlwr)
# 36 -- this represents 9 flowers per plant for 4 plants per line
mean(PerLine$NumFlwr)
# 12.7
median(PerLine$NumFlwr)
# 10
mean(PerLine$seSSN, na.rm = TRUE)
# 0.143911
# what about flower per plant information?
PerPlant <- dat_all %>% group_by(PlantID) %>%
summarize(NumFlwr = length(unique(FlowerID)), meanSSN = mean(NumShortStamens), sdSSN = sd(NumShortStamens))
PerPlant <- PerPlant %>%
mutate(seSSN = sdSSN / sqrt(NumFlwr))
summary(PerPlant)
min(PerPlant$NumFlwr)
# 1
max(PerPlant$NumFlwr)
# 9
mean(PerPlant$NumFlwr)
# 6.2
median(PerPlant$NumFlwr)
# 6
mean(PerPlant$sdSSN, na.rm = TRUE)
# 0.368523
mean(PerPlant$seSSN, na.rm = TRUE)
# 0.1586749
View(PerPlant)
View(PerPlant)
96/230
1-0.417
94/230
# how many plants have variation in short stamen number?
1 - (96/230)
1- (96/227)
View(PerPlant)
# how many plants have short stamen loss
134/230
230-96
# percentage of plants that have variation of the ones that have loss
93/96
View(PerPlant)
library(stringR)
library(stringr)
str_count("HHTTHHH")
str_count("HHTTHHH", pattern = "HH")
str_count("HHH", pattern = "HH")
?str_count()
str_count(c("a.", "...", ".a.a"), ".")
str_count(c("a.", "...", ".a.a"), fixed("."))
str_count("HHH", pattern = fixed("HH"))
str_count("HHH", pattern = coll("HH"))
str_count("HHH", pattern = boundary("HH"))
str_count("HHH", pattern = regex("HH"))
pattern <- "a.b"
strings <- c("abb", "a.b")
str_detect(strings, pattern)
str_detect(strings, fixed(pattern))
str_detect(strings, coll(pattern))
fruit <- c("apple", "banana", "pear", "pineapple")
str_count(fruit, "p")
?regex()
str_count("HHH", pattern = "H(?=H)")
str_count("HHH", pattern = "H(?=T)")
str_count("HHH", pattern = "HH")
knitr::opts_chunk$set(echo = TRUE)
nReps <- 1e5
tmp <- replicate(nReps, paste(sample(x=c("H","T"), size = 100, replace = TRUE), collapse = ""))
alice <- str_count(tmp, "HH" ) # or lapply(tmp, str_count, pattern = "HH")
bob <- str_count(tmp, "HT")
prob_bob_win <- sum(bob > alice) / nReps
paste0("The probability that Bob wins is: ", prob_bob_win, ". Bob is more likely to win than Alice.")
# function to do it all
coin_seq <- function(nReps, Seq1 = "H(?=H)", Seq2 = "H(?=H)"){
tmp <- replicate(nReps, paste(sample(x=c("H","T"), size = 100, replace = TRUE), collapse = ""))
alice <- str_count(tmp, Seq1 )
bob <- str_count(tmp, Seq2)
prob_bob_win <- sum(bob > alice) / nReps
paste0("The probability that Bob wins is: ", prob_bob_win, ". Bob is more likely to win than Alice.")
return(prob_bob_win)
}
coin_seq(1e5)
# function to do it all
coin_seq <- function(nReps, Seq1 = "H(?=H)", Seq2 = "H(?=T)"){
tmp <- replicate(nReps, paste(sample(x=c("H","T"), size = 100, replace = TRUE), collapse = ""))
alice <- str_count(tmp, Seq1 )
bob <- str_count(tmp, Seq2)
prob_bob_win <- sum(bob > alice) / nReps
paste0("The probability that Bob wins is: ", prob_bob_win, ". Bob is more likely to win than Alice.")
return(prob_bob_win)
}
coin_seq(1e5)
coin_seq(1e5)
coin_seq(1e5)
coin_seq(1e5)
coin_seq(1e5)
coin_seq(1e5)
# function to do it all
coin_seq <- function(nReps, Seq1 = "H(?=H)", Seq2 = "H(?=T)"){
tmp <- replicate(nReps, paste(sample(x=c("H","T"), size = 100, replace = TRUE), collapse = ""))
alice <- str_count(tmp, Seq1 )
bob <- str_count(tmp, Seq2)
prob_bob_win <- sum(bob > alice) / nReps
#paste0()
return("The probability that Bob wins is: ", prob_bob_win, ".")
}
coin_seq(1e5)
# function to do it all
coin_seq <- function(nReps, Seq1 = "H(?=H)", Seq2 = "H(?=T)"){
tmp <- replicate(nReps, paste(sample(x=c("H","T"), size = 100, replace = TRUE), collapse = ""))
alice <- str_count(tmp, Seq1 )
bob <- str_count(tmp, Seq2)
prob_bob_win <- sum(bob > alice) / nReps
paste0("The probability that Bob wins is: ", prob_bob_win, ".")
}
coin_seq(1e5)
# test of str_count function
str_count("HHH", pattern = "HH")
# 1 - wrong
str_count("HHH", pattern = "H(?=H)")
# 2 - yay
# function to do it all
coin_seq <- function(nReps, Seq1 = "H(?=H)", Seq2 = "H(?=T)"){
tmp <- replicate(nReps, paste(sample(x=c("H","T"), size = 100, replace = TRUE), collapse = ""))
alice <- str_count(tmp, Seq1 )
bob <- str_count(tmp, Seq2)
prob_bob_win <- sum(bob > alice) / nReps
paste0("The probability that Bob wins is: ", prob_bob_win, ".")
}
coin_seq(1e5)
coin_seq(1e5)
coin_seq(1e5)
coin_seq(1e5)
coin_seq(1e5)
